| **Inicio**         | **atrás 9**          | **Siguiente 11**          |
| ------------------ | -------------------- | ------------------------- |
| [🏠](../README.md) | [⏪](./13_9_head.md) | [⏩](./13_11_nslookup.md) |

---

## **Índice**

| Temario                                                  |
| -------------------------------------------------------- |
| [430. comando grep en Linux](#430-comando-grep-en-linux) |
| [431. El comando grep](#431-el-comando-grep)             |

# **grep**

## **430. comando grep en Linux**

![grep](/img/13_Tools_for_Incident_Response_and_Discovery/grep.webp "grep")

### 1. ¿Qué es Grep?

`grep` (Global Regular Expression Print) es una herramienta de línea de comandos en Linux/Unix que sirve para **buscar texto dentro de archivos o flujos de datos**.

- Utiliza **expresiones regulares** para encontrar coincidencias.
- Puede buscar dentro de **uno o varios archivos**.
- Resalta o imprime las **líneas que coinciden** con el patrón indicado.

En palabras simples: es como un **CTRL+F** pero desde la terminal y mucho más poderoso.

### 2. Comando Grep en Linux

#### Sintaxis básica

```bash
grep [OPCIONES] 'patrón' archivo
```

#### Opciones más usadas

- `-i` → ignora mayúsculas/minúsculas.
- `-n` → muestra el número de línea.
- `-r` o `-R` → búsqueda recursiva en directorios.
- `-v` → muestra líneas que **NO** coinciden.
- `-c` → muestra el número de coincidencias.
- `-l` → muestra solo los nombres de archivos con coincidencias.
- `-w` → busca palabras completas.
- `--color=auto` → resalta coincidencias.

### 3. Casos de uso más comunes del comando `grep`

#### 🔹 1) Buscar una palabra en un archivo

```bash
grep "error" archivo.log
```

👉 Muestra todas las líneas que contienen la palabra `error`.

#### 🔹 2) Ignorar mayúsculas y minúsculas

```bash
grep -i "error" archivo.log
```

👉 Coincide con `error`, `Error`, `ERROR`, etc.

#### 🔹 3) Mostrar número de línea

```bash
grep -n "warning" archivo.log
```

👉 Ejemplo de salida:

```
23:2025-09-15 10:02:34 WARNING Connection timeout
57:2025-09-15 10:03:10 WARNING Slow response
```

#### 🔹 4) Buscar en varios archivos

```bash
grep "main()" *.c
```

👉 Busca la palabra `main()` en todos los archivos `.c` del directorio.

#### 🔹 5) Buscar recursivamente en carpetas

```bash
grep -r "TODO" /home/usuario/proyecto/
```

👉 Encuentra comentarios `TODO` en todo el proyecto.

#### 🔹 6) Mostrar solo el nombre de los archivos que coinciden

```bash
grep -l "ERROR" *.log
```

👉 Lista solo los archivos que contienen la palabra `ERROR`.

#### 🔹 7) Contar coincidencias

```bash
grep -c "failed" archivo.log
```

👉 Ejemplo de salida:

```
12
```

(12 coincidencias encontradas)

#### 🔹 8) Mostrar líneas que **NO** coinciden

```bash
grep -v "DEBUG" archivo.log
```

👉 Muestra todas las líneas **excepto** las que contienen `DEBUG`.

#### 🔹 9) Buscar una palabra completa

```bash
grep -w "cat" animales.txt
```

👉 Coincide con `cat`, pero **no** con `category` o `concatenate`.

#### 🔹 10) Usar expresiones regulares

```bash
grep -E "ERROR|WARNING" archivo.log
```

👉 Busca todas las líneas que contengan **ERROR** o **WARNING**.

#### 🔹 11) Combinar con otros comandos

- Ver procesos que contienen `ssh`:

```bash
ps aux | grep ssh
```

- Ver conexiones que usan el puerto 80:

```bash
netstat -tulnp | grep 80
```

- Buscar usuarios en `/etc/passwd`:

```bash
grep "/bin/bash" /etc/passwd
```

### 4. Preguntas frecuentes (FAQ)

**❓ grep es sensible a mayúsculas/minúsculas?**

👉 Sí, pero puedes usar `-i` para ignorarlas.

**❓ Puedo buscar en subdirectorios?**

👉 Sí, con `grep -r`.

**❓ Cómo busco varias palabras?**

👉 Usa expresiones regulares con `-E`, ejemplo:

```bash
grep -E "error|fail|critical" archivo.log
```

**❓ Puedo combinar `grep` con `tail` o `head`?**

👉 Sí, ejemplo:

```bash
tail -f archivo.log | grep "ERROR"
```

Muestra en tiempo real solo las líneas con `ERROR`.

### 5. Conclusión

El comando **`grep`** es una de las herramientas más potentes de Linux/Unix para **buscar, filtrar y analizar texto**. Desde localizar errores en logs hasta buscar patrones complejos con expresiones regulares, `grep` es indispensable tanto para administradores de sistemas como para programadores.

👉 **Aprender `grep` es dar un gran paso hacia el dominio de la terminal en Linux.**

---

[🔼](#índice)

---

## **431. El comando grep**

# El comando `grep` — explicación bien detallada con ejemplos

`grep` (**G**lobal **R**egular **E**xpression **P**rint) es la herramienta de búsqueda por excelencia en Unix/Linux. Busca patrones (normalmente expresiones regulares) en archivos o en la entrada estándar y devuelve las líneas que coinciden. Es pequeño, rápido y enormemente flexible — imprescindible para depurar, analizar logs, buscar en código, pipelines, etc.

A continuación tienes una guía completa: qué hace, sintaxis, opciones clave, ejemplos prácticos (desde lo básico hasta regex avanzadas), trucos de rendimiento y errores comunes.

---

# 1) ¿Qué es `grep`?

`grep` es un filtro de texto que:

- recibe uno o varios archivos o lee `stdin`,
- busca coincidencias con un _patrón_ (texto literal o expresión regular),
- imprime las líneas que contienen ese patrón (por defecto),
- tiene muchas opciones: búsquedas recursivas, insensitivas, mostrar número de línea, contexto, etc.

Es una herramienta no interactiva, pensada para usarse en scripts o en la terminal.

---

# 2) Sintaxis básica

```bash
grep [OPCIONES] 'PATRÓN' [ARCHIVO...]
```

Si no indicas `ARCHIVO`, `grep` lee de la entrada estándar:

```bash
command | grep 'error'
```

### Salida típica

Por cada línea que coincida, `grep` imprime la línea completa (salvo que uses `-o` para imprimir solo la porción coincidente).

---

# 3) Opciones esenciales (cheat-sheet rápido)

- `-i` → ignorar mayúsculas/minúsculas.
- `-n` → mostrar número de línea.
- `-r` / `-R` → recursivo en directorios.
- `-v` → invertir la coincidencia (mostrar líneas que **no** coinciden).
- `-c` → contar coincidencias por archivo.
- `-l` → listar sólo nombres de archivos que contienen coincidencias.
- `-L` → listar archivos **sin** coincidencias.
- `-w` → palabra completa (coincide `cat` pero no `category`).
- `-o` → mostrar sólo la parte coincidente (una por línea).
- `-E` → usar expresiones regulares extendidas (equivalente a `egrep`).
- `-F` → _fixed strings_ (búsqueda literal, muy rápida; equivalente a `fgrep`).
- `-P` → usar PCRE (Perl-compatible regex) — más potente (lookarounds, lazy quantifiers) — no siempre disponible en todas las builds.
- `--color=auto` → resaltar coincidencias.
- `-A NUM` → mostrar NUM líneas **After** (después) de la coincidencia.
- `-B NUM` → mostrar NUM líneas **Before** (antes) de la coincidencia.
- `-C NUM` → contexto: `-A NUM -B NUM` (ambos).
- `--exclude`, `--include` → incluir/excluir archivos por patrón en búsquedas recursivas.
- `-s` → suprimir mensajes de error por archivos inexistentes.

---

# 4) Comportamiento / códigos de salida

- Código `0` → al menos una coincidencia encontrada.
- Código `1` → no se encontró ninguna coincidencia.
- Código `2` → error (por ejemplo, archivo no accesible).

Esto es útil en scripts (`if grep -q 'pat' file; then ...`).

---

# 5) Ejemplos básicos y su explicación

### a) Buscar texto simple en un archivo

```bash
grep "error" /var/log/syslog
```

Imprime todas las líneas que contienen la cadena `error` (sensible a mayúsculas).

### b) Ignorar mayúsculas

```bash
grep -i "error" /var/log/syslog
```

Coincide con `Error`, `ERROR`, etc.

### c) Mostrar número de línea

```bash
grep -n "TODO" *.py
# salida ejemplo:
# script.py:42:# TODO: mejorar validación
```

### d) Búsqueda recursiva en un proyecto

```bash
grep -R --color=auto "deprecated_function" src/
```

### e) Mostrar sólo nombres de archivos que contienen el patrón

```bash
grep -l "main(" *.c
```

Devuelve una lista de archivos que deben inspeccionarse más a fondo.

### f) Contar coincidencias

```bash
grep -c "ERROR" app.log
# salida: 17
```

### g) Mostrar sólo la porción que coincide

```bash
echo "user:juan@example.com" | grep -o '[[:alnum:]._-]\+@[[:alnum:].-]\+'
# salida: juan@example.com
```

---

# 6) Contexto alrededor de la coincidencia

A veces interesa ver las líneas antes/después:

```bash
grep -n -C 3 "Exception" app.log   # 3 líneas de contexto (antes y después)
grep -n -A 2 "Started" app.log      # 2 líneas AFTER
grep -n -B 4 "ERROR" app.log        # 4 líneas BEFORE
```

---

# 7) Búsqueda de palabra completa y patrones literales

- `-w` asegura coincidencia por palabra:

```bash
grep -w "cat" file.txt   # no casará "category"
```

- `-F` busca literales (útil si el patrón contiene metacaracteres que no quieres interpretar):

```bash
grep -F 'a+b' file.txt   # buscará la cadena literal "a+b"
```

---

# 8) Expresiones regulares — ejemplos prácticos

### Expresiones POSIX básicas con `grep` (sin `-E`)

- `^` inicio de línea, `$` fin de línea, `.` cualquier carácter, `*` repetición 0+, `[]` clases, `\{m,n\}` repeticiones.

```bash
grep "^ERROR" logs.txt     # líneas que empiezan por ERROR
grep "timeout$" logs.txt   # líneas que terminan en timeout
grep "^[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}" logs.txt  # fechas YYYY-MM-DD al inicio
```

### Regex extendidas con `-E`

```bash
grep -E "ERROR|WARN" logs.txt     # OR alternation
```

### PCRE con `-P` (lookarounds, lazy, etc.)

```bash
# extraer lo que está entre paréntesis (sin incluir los paréntesis)
echo "foo(bar) baz" | grep -Po '(?<=\().+?(?=\))'
# salida: bar
```

`-P` y `-o` juntos son muy útiles para extracción.

---

# 9) Usos prácticos en pipelines

### Buscar procesos

```bash
ps aux | grep -i ssh
```

### Ver conexiones de red en puerto 80

```bash
ss -tnlp | grep ':80 '
# o
netstat -tulnp | grep ':80'
```

### Filtrar logs en tiempo real

```bash
tail -F /var/log/nginx/access.log | grep --line-buffered ' 500 '
```

`--line-buffered` evita buffers y muestra coincidencias enseguida.

---

# 10) Búsquedas recursivas avanzadas e ignorar archivos

```bash
# buscar en directorio pero excluir node_modules
grep -R --exclude-dir=node_modules "TODO" .

# buscar sólo en .py y .sh
grep -R --include='*.py' --include='*.sh' "import " project/
```

---

# 11) Extracción y transformación (ejemplos útiles)

### Extraer emails de archivos

```bash
grep -oP '[\w.+-]+@[\w.-]+' file.txt | sort -u
```

### Mostrar sólo URLs

```bash
grep -oP 'https?://[^\s]+' file.txt
```

### Buscar líneas duplicadas o contarlas por patrón

```bash
grep -oP '^[^ ]+' access.log | sort | uniq -c | sort -nr
# cuenta accesos por IP (ejemplo)
```

---

# 12) Performance y buenas prácticas

- Para búsquedas literales rápidas usa `-F`.
- Para máxima velocidad en texto plano puedes forzar la localización a C:

```bash
LC_ALL=C grep -R "patrón" .
```

`LC_ALL=C` suele acelerar porque usa ordenamiento/colación simple (ASCII).

- Para proyectos grandes considera `ripgrep` (`rg`) o `the_silver_searcher (ag)` — son alternativas mucho más rápidas y con sintaxis similar.
- Evita `cat file | grep pattern` cuando `grep pattern file` funciona (evita un proceso extra).

---

# 13) Gotchas y puntos a tener en cuenta

- **Escapar caracteres**: en la shell, caracteres especiales (`*`, `?`, `[]`, `$`, `()`, `\`) pueden necesitar comillas o escape.

  ```bash
  grep '\$PATH' file        # busca literal $PATH; es mejor con comillas simples
  grep -F '$PATH' file      # o fixed-string
  ```

- **Binary files**: si pasas binarios, `grep` puede decir `Binary file matches`. Usa `-a` (`--binary-files=text`) para tratarlos como texto.
- **Unicode/locale**: coincidencias con caracteres multibyte dependen de la locale; `LC_ALL=C` cambia comportamiento.
- **Salida en scripts**: usa `-q` (quiet) si sólo te interesa el código de salida:

  ```bash
  if grep -q 'ERROR' file; then echo "hay error"; fi
  ```

---

# 14) Ejemplos avanzados (combinados)

### Encontrar funciones en código (Python)

```bash
grep -n -E "^def [a-zA-Z0-9_]+\(" -R src/
```

### Detectar TODOs y mostrar contexto

```bash
grep -n -R -C 2 "TODO" project/
```

### Buscar archivos sin un patrón (por ejemplo, sin license)

```bash
grep -L "Copyright" *.py
```

---

# 15) Alternativas y herramientas relacionadas

- `egrep` / `fgrep` (obsoletos; `-E` y `-F` son preferibles).
- `ripgrep (rg)` — búsqueda recursiva ultra rápida y sensible a .gitignore.
- `ag (the_silver_searcher)` — otra alternativa veloz.
- `awk` / `sed` — para procesamientos más complejos de las líneas encontradas.

---

# 16) Conclusión

`grep` es la herramienta fundamental para buscar y filtrar texto en Unix/Linux. Dominar sus opciones (contexto, recursividad, expresiones regulares y modos `-F`, `-P`) multiplicará tu productividad al trabajar con logs, código y pipelines. Para tareas muy grandes o de desarrollo, considera `ripgrep` por rendimiento, pero `grep` sigue siendo imprescindible para scripts y administración.

---

¿Quieres que te prepare un **cheat-sheet imprimible** con los comandos `grep` más usados y sus ejemplos rápidos?
O si prefieres, puedo darte **5 ejercicios prácticos** con soluciones para que practiques (buscar emails, contar errores, extraer URLs, etc.). ¿Cuál quieres?

---

[🔼](#índice)

---

| **Inicio**         | **atrás 9**          | **Siguiente 11**          |
| ------------------ | -------------------- | ------------------------- |
| [🏠](../README.md) | [⏪](./13_9_head.md) | [⏩](./13_11_nslookup.md) |
