| **Inicio**         | **atr√°s 5**         | **Siguiente 7**      |
| ------------------ | ------------------- | -------------------- |
| [üè†](../README.md) | [‚è™](./13_5_cat.md) | [‚è©](./13_7_tail.md) |

---

## **√çndice**

| Temario                                                                                |
| -------------------------------------------------------------------------------------- |
| [422. Cu√°ndo y c√≥mo utilizar el comando dd](#422-cu√°ndo-y-c√≥mo-utilizar-el-comando-dd) |
| [423. C√≥mo usar el comando dd en Linux](#423-c√≥mo-usar-el-comando-dd-en-linux)         |

# **dd**

## **422. Cu√°ndo y c√≥mo utilizar el comando dd**

![dd](/img/13_Tools_for_Incident_Response_and_Discovery/dd.png "dd")

### 1. Descripci√≥n general

`dd` (dataset definition, de la √©poca de mainframes IBM) es una utilidad de bajo nivel en Unix/Linux que **copia y convierte datos byte por byte** entre archivos o dispositivos.

Se usa para:

- Copiar discos o particiones.
- Crear im√°genes de discos.
- Restaurar im√°genes a discos (p. ej. ISO a USB).
- Hacer backups de bajo nivel.
- Medir velocidad de lectura/escritura.

üëâ Sintaxis general:

```bash
dd if=FUENTE of=DESTINO [opciones]
```

- `if=` = _input file_ (fuente).
- `of=` = _output file_ (destino).
- Opciones comunes:

  - `bs=` tama√±o de bloque (ej. `bs=4M`)
  - `count=` n√∫mero de bloques a copiar
  - `status=progress` mostrar progreso

Ejemplo sencillo:

```bash
dd if=archivo.iso of=/dev/sdb bs=4M status=progress
```

Esto copia la ISO a la unidad USB en `/dev/sdb`.

### 2. `dd` y ‚ÄúTodo es un archivo‚Äù de Unix

En Unix, **todo se trata como un archivo**:

- Archivos de texto/binarios.
- Dispositivos (`/dev/sda`, `/dev/zero`, `/dev/random`).
- Particiones (`/dev/sda1`).
- Flujos de datos (stdin/stdout).

`dd` aprovecha esto: puedes leer de un archivo especial y escribir en otro.

Ejemplos:

- Crear un archivo lleno de ceros de 100 MB:

```bash
dd if=/dev/zero of=archivo.img bs=1M count=100
```

- Generar un archivo con datos aleatorios (√∫til para pruebas de seguridad):

```bash
dd if=/dev/urandom of=random.bin bs=1M count=50
```

### 3. Cu√°ndo **NO** usar `dd`

- ‚ùå **Clonado casual de discos** sin estar 100% seguro de `if` y `of` ‚Üí puedes sobreescribir todo un disco.
- ‚ùå **Copias simples de archivos** ‚Üí usa `cp` o `rsync`, son m√°s r√°pidas y seguras.
- ‚ùå **Respaldo de sistemas de archivos en uso** ‚Üí puede corromper datos. Usa herramientas como `rsync`, `tar` o snapshots (`LVM`, `btrfs`).
- ‚ùå **Procesos largos sin feedback** ‚Üí si olvidas `status=progress`, no sabr√°s si avanza.

En resumen: √∫salo para **tareas de bajo nivel**, no para copias normales.

### 4. Copiar un archivo de imagen a una unidad USB

Supongamos que descargaste `ubuntu.iso` y quieres grabarlo en un USB en `/dev/sdb`.

‚ö†Ô∏è **Verifica bien la unidad destino** con:

```bash
lsblk
```

Comando:

```bash
sudo dd if=ubuntu.iso of=/dev/sdb bs=4M status=progress oflag=sync
```

- `bs=4M` ‚Üí bloques de 4 MB (mejora la velocidad).
- `status=progress` ‚Üí muestra el avance.
- `oflag=sync` ‚Üí asegura que los datos se escriban inmediatamente.

Despu√©s, expulsa con:

```bash
sync
sudo eject /dev/sdb
```

### 5. Creando nuestros propios archivos de imagen de disco

- **Backup de un disco a una imagen**:

```bash
sudo dd if=/dev/sda of=backup.img bs=64K status=progress
```

- **Restaurar la imagen al disco**:

```bash
sudo dd if=backup.img of=/dev/sda bs=64K status=progress
```

- **Clonar directamente entre discos**:

```bash
sudo dd if=/dev/sda of=/dev/sdb bs=64K status=progress
```

- **Medir velocidad de escritura del disco**:

```bash
dd if=/dev/zero of=testfile bs=1G count=1 oflag=dsync
```

### 6. Antecedentes hist√≥ricos

- `dd` naci√≥ en los **a√±os 70 en UNIX**.
- Su nombre viene del **JCL (Job Control Language)** de IBM, donde `DD` (Data Definition) defin√≠a archivos.
- Se dise√±√≥ para copiar datos entre cintas, discos y dispositivos de forma ‚Äúciega‚Äù (sin interpretar contenido).
- Hoy en d√≠a sigue siendo b√°sico en administraci√≥n de sistemas, aunque complementado con herramientas m√°s modernas como `ddrescue` (para recuperar discos da√±ados).

### 7. Conclusi√≥n

`dd` es un **cuchillo suizo de bajo nivel** en Unix/Linux:

- Sirve para crear, copiar, clonar, restaurar y medir datos directamente.
- Funciona porque en Unix **todo es un archivo**, incluso los dispositivos.
- Hay que usarlo con cuidado: un error en `if`/`of` puede borrar todo un disco.
- Aunque su sintaxis es antigua, sigue siendo esencial para administradores de sistemas y seguridad inform√°tica.

üëâ Para tareas simples, mejor usar `cp`, `rsync` o `tar`. Para clonado de discos/USBs, `dd` sigue siendo el rey.

---

[üîº](#√≠ndice)

---

## **423. C√≥mo usar el comando dd en Linux**

### Resumen r√°pido

`dd` copia datos **byte a byte** entre _archivos_ o _dispositivos_ (`if=` input file, `of=` output file). Se usa para crear im√°genes, clonar discos/particiones, generar archivos de prueba, borrar unidades, medir I/O y m√°s.

Sintaxis b√°sica:

```bash
sudo dd if=ORIGEN of=DESTINO [bs=BLOCKSIZE] [count=N] [opciones]
```

Siempre ejecuta con `sudo` cuando trabajas con dispositivos de bloque (`/dev/sdX`).

### Antes de empezar ‚Äî checklist de seguridad

1. **Identifica correctamente** el dispositivo destino: `lsblk`, `blkid`, `fdisk -l`.
2. **Desmonta** la partici√≥n del destino: `sudo umount /dev/sdb1` (si est√° montada).
3. **Haz backup** si hay datos importantes.
4. Revisa dos veces `if=` y `of=`. El orden importa: `if=/dev/sda of=/dev/sdb` copia sda ‚Üí sdb.
5. Usa `status=progress` o `pv` para ver progreso.
6. Ten paciencia ‚Äî operaciones con `dd` pueden tardar bastante.

### Opciones importantes y qu√© hacen

- `if=` : archivo / dispositivo de entrada (input file).
- `of=` : archivo / dispositivo de salida (output file).
- `bs=` : tama√±o de bloque (ej. `bs=4M`, `bs=64K`). Afecta rendimiento.
- `count=` : n√∫mero de bloques a copiar (stop despu√©s de `count*bs` bytes).
- `skip=` : omite N bloques del _input_ antes de copiar.
- `seek=` : omite N bloques en el _output_ antes de comenzar a escribir (√∫til para escribir a partir de offset).
- `conv=` : conversiones (ej.: `notrunc`, `noerror`, `sync`, `sparse`, `fdatasync`, `swab`, `ucase`, `lcase`).

  - `noerror` : contin√∫a aunque haya errores de lectura.
  - `sync` : rellena bloques cortos con ceros para mantener offsets.
  - `notrunc` : no trunca el archivo de salida.
  - `sparse` : crea archivos sparse al copiar.
  - `fdatasync` / `fsync` : asegurar escritura al disco antes de finalizar.

- `oflag=` / `iflag=` : flags del I/O, p. ej. `direct`, `sync`.

  - `oflag=direct` : evita cache del kernel (m√°s real para tests de disco).
  - `oflag=sync` : escribe sincronamente.

- `status=progress` : muestra progreso (en dd moderno).
- En sistemas sin `status=progress`, puedes enviar se√±al USR1 al proceso `dd` para que imprima progreso:

  - `sudo kill -USR1 $(pgrep ^dd$)` (ejec√∫talo en otro terminal).

### Ejemplos pr√°cticos (explicados paso a paso)

#### 1) Crear un archivo de imagen vac√≠o (100 MB)

```bash
dd if=/dev/zero of=imagen.img bs=1M count=100 status=progress
```

- `if=/dev/zero` genera ceros; `bs=1M count=100` => 100 MB.

#### 2) Crear un archivo ‚Äúsparse‚Äù (archivo de gran tama√±o que no ocupa espacio f√≠sico)

```bash
dd if=/dev/zero of=sparse.img bs=1 count=0 seek=1G
```

- `count=0 seek=1G` crea archivo con tama√±o l√≥gico 1 GiB sin escribir datos reales.

#### 3) Escribir una ISO a una USB (crear USB booteable)

1. Identifica la unidad: `lsblk` ‚Üí digamos `/dev/sdb`.
2. Desmonta cualquier partici√≥n en `/dev/sdb`.
3. Ejecuta:

```bash
sudo dd if=ubuntu.iso of=/dev/sdb bs=4M status=progress oflag=sync
sudo sync
```

- `of=/dev/sdb` (no /dev/sdb1). `oflag=sync` fuerza sincron√≠a; `sync` asegura que el kernel vac√≠e buffers.

#### 4) Hacer imagen completa de un disco (backup bit a bit)

```bash
sudo dd if=/dev/sda of=/path/to/backup-sda.img bs=64K status=progress
```

- Para comprimir al vuelo:

```bash
sudo dd if=/dev/sda bs=64K status=progress | gzip > backup-sda.img.gz
```

#### 5) Restaurar imagen a disco

```bash
gunzip -c backup-sda.img.gz | sudo dd of=/dev/sda bs=64K status=progress
```

#### 6) Clonar disco a disco

```bash
sudo dd if=/dev/sda of=/dev/sdb bs=64K status=progress conv=noerror,sync
```

- `noerror` contin√∫a ante errores; `sync` rellena bloques cortos con ceros (mantiene offsets).

#### 7) Copiar s√≥lo los primeros N bytes (p. ej. MBR / primeros 512 bytes)

- Copiar MBR completo (512 bytes):

```bash
sudo dd if=/dev/sda of=mbr.bin bs=512 count=1
```

- Copiar s√≥lo boot code (primeros 446 bytes):

```bash
sudo dd if=/dev/sda of=bootcode.bin bs=446 count=1
```

> Nota: la tabla de particiones es los 64 bytes siguientes (446..510).

#### 8) Extraer una partici√≥n a partir de sectores (usar `skip`)

Si la partici√≥n comienza en el sector 2048 (sector=512 bytes):

```bash
sudo dd if=/dev/sda of=part1.img bs=512 skip=2048 status=progress
```

- Para restaurarla al mismo offset en otro disco usa `seek=2048`:

```bash
sudo dd if=part1.img of=/dev/sdb bs=512 seek=2048 status=progress
```

#### 9) Borrar un disco (sobrescribir con ceros o aleatorios)

- Sobrescribir con ceros (r√°pido):

```bash
sudo dd if=/dev/zero of=/dev/sdx bs=4M status=progress oflag=sync
```

- Sobrescribir con datos aleatorios (m√°s seguro, lento):

```bash
sudo dd if=/dev/urandom of=/dev/sdx bs=1M status=progress
```

> Para borrar de forma segura varias pasadas, es mejor usar `shred` u otras utilidades dise√±adas para ello.

#### 10) Medir rendimiento de escritura (benchmark simple)

```bash
sudo dd if=/dev/zero of=testfile bs=1G count=1 oflag=direct status=progress
```

- `oflag=direct` evita cache y te da velocidad real del disco.

#### 11) Ver progreso en versiones antiguas de `dd`

Si `status=progress` no existe:

1. Inicia `dd` en una terminal.
2. En otra terminal, manda se√±al:

```bash
sudo pkill -USR1 -n dd
# o
sudo kill -USR1 <pid_de_dd>
```

`dd` imprimir√° al stderr estad√≠sticas (bytes copiados y velocidad).

#### 12) Usar `pv` para ver progreso y tasa (si lo tienes instalado)

```bash
pv ubuntu.iso | sudo dd of=/dev/sdb bs=4M oflag=sync
# o para im√°genes grandes
sudo dd if=/dev/sda bs=64K | pv | gzip > backup.img.gz
```

#### 13) Evitar truncar el archivo de salida (√∫til al escribir dentro de un archivo existente)

```bash
dd if=data.bin of=bigfile.img bs=512 seek=2048 conv=notrunc
```

`notrunc` evita truncar el archivo de salida antes de escribir.

### `conv=`: usos frecuentes y explicaci√≥n

- `noerror` ‚Üí continuar aunque existan errores de lectura.
- `sync` ‚Üí rellena bloques cortos con ceros, √∫til con `noerror` para mantener offsets.
- `fdatasync` / `fsync` ‚Üí fuerza sincronizaci√≥n al terminar.
- `sparse` ‚Üí crear archivos sparse (ahorra espacio).
- `swab` ‚Üí byte-swap pares (muy espec√≠fico).
- `ucase` / `lcase` ‚Üí convertir may√∫sc/min√∫sc (raro en uso real).

Ejemplo combinando:

```bash
sudo dd if=/dev/sda of=backup.img conv=noerror,sync bs=64K status=progress
```

### Verificaci√≥n despu√©s de copiar

Siempre verifica integridad:

- Generar suma en origen y destino:

```bash
sha256sum ubuntu.iso
sha256sum /dev/sdb   # NO funciona directamente; mejor verificar contenido escrito:
sudo dd if=/dev/sdb bs=4M count=xxxx | sha256sum
# o comparar imagen:
sudo dd if=/dev/sdb bs=4M count=xxxx | gzip > copy.gz
```

O mejor: calcula suma del archivo .iso y compara con la suma provista por la distribucion; tras escribir a USB, puedes montar la USB y comparar archivos.

### Casos de uso avanzados

- **Recuperaci√≥n de discos con sectores da√±ados**: usa `ddrescue` o `dd_rescue` ‚Äî herramientas m√°s tolerantes y con logs de reparo.
- **Crear im√°genes comprimidas y manejar espacio**: `dd if=/dev/sda | gzip > /mnt/backup/sda.img.gz`.
- **Crear im√°genes de dispositivos remotos**:

```bash
sudo dd if=/dev/sda | ssh user@host "cat > /path/backup.img"
```

### Errores comunes y c√≥mo evitarlos

- Confundir partici√≥n con disco: escribir a `/dev/sdb1` vs `/dev/sdb`.
- No desmontar el dispositivo antes de escribir.
- Usar `bs` demasiado peque√±o ‚Üí baja velocidad. Usar valores razonables: `bs=64K` a `bs=4M` seg√∫n el caso.
- No usar `status=progress` ‚Üí pensar que `dd` ‚Äúse qued√≥ pegado‚Äù.
- No usar `oflag=sync` cuando necesitas asegurar escritura inmediata.

### Alternativas / herramientas complementarias

- `cp` / `rsync` ‚Üí para copiar archivos y directorios.
- `partclone`, `fsarchiver` ‚Üí para clonar particiones manteniendo s√≥lo bloques usados.
- `ddrescue` ‚Üí recuperaci√≥n segura de discos da√±ados.
- `pv` ‚Üí ver progreso, tasa y ETA cuando combinas tuber√≠as.
- `shred` ‚Üí borrado seguro multi-pasada.

### Ejemplo pr√°ctico ‚Äî flujo completo: grabar ISO a USB y verificar

1. Conecta USB. Encu√©ntralo:

```bash
lsblk
# supongamos /dev/sdb
```

2. Desmonta las particiones:

```bash
sudo umount /dev/sdb*
```

3. Graba ISO:

```bash
sudo dd if=ubuntu.iso of=/dev/sdb bs=4M status=progress oflag=sync
```

4. Fuerza escritura final:

```bash
sync
```

5. Monta la USB y verifica (compara archivo, o revisa que arranque en otra m√°quina/VM).

### Conclusi√≥n y buenas pr√°cticas finales

- `dd` es extremadamente potente y vers√°til, pero **peligroso** si se usa sin cuidado.
- Usa `lsblk`/`fdisk -l` para identificar dispositivos, desmonta antes, y confirma `if`/`of`.
- Prefiere `status=progress` o `pv` para visibilidad; usa `oflag=sync` o `sync` para asegurar datos.
- Para recuperaci√≥n, prefiere `ddrescue`.
- Para copias de archivos normales, usa `cp`/`rsync`.

---

[üîº](#√≠ndice)

---

| **Inicio**         | **atr√°s 5**         | **Siguiente 7**      |
| ------------------ | ------------------- | -------------------- |
| [üè†](../README.md) | [‚è™](./13_5_cat.md) | [‚è©](./13_7_tail.md) |
