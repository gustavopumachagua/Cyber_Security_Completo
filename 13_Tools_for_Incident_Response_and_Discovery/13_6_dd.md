| **Inicio**         | **atrÃ¡s 5**         | **Siguiente 7**      |
| ------------------ | ------------------- | -------------------- |
| [ğŸ ](../README.md) | [âª](./13_5_cat.md) | [â©](./13_7_tail.md) |

---

## **Ãndice**

| Temario                                                                                |
| -------------------------------------------------------------------------------------- |
| [422. CuÃ¡ndo y cÃ³mo utilizar el comando dd](#422-cuÃ¡ndo-y-cÃ³mo-utilizar-el-comando-dd) |
| [423. CÃ³mo usar el comando dd en Linux](#423-cÃ³mo-usar-el-comando-dd-en-linux)         |

# **dd**

## **422. CuÃ¡ndo y cÃ³mo utilizar el comando dd**

![dd](/img/13_Tools_for_Incident_Response_and_Discovery/dd.png "dd")

### 1. DescripciÃ³n general

`dd` (dataset definition, de la Ã©poca de mainframes IBM) es una utilidad de bajo nivel en Unix/Linux que **copia y convierte datos byte por byte** entre archivos o dispositivos.

Se usa para:

- Copiar discos o particiones.
- Crear imÃ¡genes de discos.
- Restaurar imÃ¡genes a discos (p. ej. ISO a USB).
- Hacer backups de bajo nivel.
- Medir velocidad de lectura/escritura.

ğŸ‘‰ Sintaxis general:

```bash
dd if=FUENTE of=DESTINO [opciones]
```

- `if=` = _input file_ (fuente).
- `of=` = _output file_ (destino).
- Opciones comunes:

  - `bs=` tamaÃ±o de bloque (ej. `bs=4M`)
  - `count=` nÃºmero de bloques a copiar
  - `status=progress` mostrar progreso

Ejemplo sencillo:

```bash
dd if=archivo.iso of=/dev/sdb bs=4M status=progress
```

Esto copia la ISO a la unidad USB en `/dev/sdb`.

### 2. `dd` y â€œTodo es un archivoâ€ de Unix

En Unix, **todo se trata como un archivo**:

- Archivos de texto/binarios.
- Dispositivos (`/dev/sda`, `/dev/zero`, `/dev/random`).
- Particiones (`/dev/sda1`).
- Flujos de datos (stdin/stdout).

`dd` aprovecha esto: puedes leer de un archivo especial y escribir en otro.

Ejemplos:

- Crear un archivo lleno de ceros de 100 MB:

```bash
dd if=/dev/zero of=archivo.img bs=1M count=100
```

- Generar un archivo con datos aleatorios (Ãºtil para pruebas de seguridad):

```bash
dd if=/dev/urandom of=random.bin bs=1M count=50
```

### 3. CuÃ¡ndo **NO** usar `dd`

- âŒ **Clonado casual de discos** sin estar 100% seguro de `if` y `of` â†’ puedes sobreescribir todo un disco.
- âŒ **Copias simples de archivos** â†’ usa `cp` o `rsync`, son mÃ¡s rÃ¡pidas y seguras.
- âŒ **Respaldo de sistemas de archivos en uso** â†’ puede corromper datos. Usa herramientas como `rsync`, `tar` o snapshots (`LVM`, `btrfs`).
- âŒ **Procesos largos sin feedback** â†’ si olvidas `status=progress`, no sabrÃ¡s si avanza.

En resumen: Ãºsalo para **tareas de bajo nivel**, no para copias normales.

### 4. Copiar un archivo de imagen a una unidad USB

Supongamos que descargaste `ubuntu.iso` y quieres grabarlo en un USB en `/dev/sdb`.

âš ï¸ **Verifica bien la unidad destino** con:

```bash
lsblk
```

Comando:

```bash
sudo dd if=ubuntu.iso of=/dev/sdb bs=4M status=progress oflag=sync
```

- `bs=4M` â†’ bloques de 4 MB (mejora la velocidad).
- `status=progress` â†’ muestra el avance.
- `oflag=sync` â†’ asegura que los datos se escriban inmediatamente.

DespuÃ©s, expulsa con:

```bash
sync
sudo eject /dev/sdb
```

### 5. Creando nuestros propios archivos de imagen de disco

- **Backup de un disco a una imagen**:

```bash
sudo dd if=/dev/sda of=backup.img bs=64K status=progress
```

- **Restaurar la imagen al disco**:

```bash
sudo dd if=backup.img of=/dev/sda bs=64K status=progress
```

- **Clonar directamente entre discos**:

```bash
sudo dd if=/dev/sda of=/dev/sdb bs=64K status=progress
```

- **Medir velocidad de escritura del disco**:

```bash
dd if=/dev/zero of=testfile bs=1G count=1 oflag=dsync
```

### 6. Antecedentes histÃ³ricos

- `dd` naciÃ³ en los **aÃ±os 70 en UNIX**.
- Su nombre viene del **JCL (Job Control Language)** de IBM, donde `DD` (Data Definition) definÃ­a archivos.
- Se diseÃ±Ã³ para copiar datos entre cintas, discos y dispositivos de forma â€œciegaâ€ (sin interpretar contenido).
- Hoy en dÃ­a sigue siendo bÃ¡sico en administraciÃ³n de sistemas, aunque complementado con herramientas mÃ¡s modernas como `ddrescue` (para recuperar discos daÃ±ados).

### 7. ConclusiÃ³n

`dd` es un **cuchillo suizo de bajo nivel** en Unix/Linux:

- Sirve para crear, copiar, clonar, restaurar y medir datos directamente.
- Funciona porque en Unix **todo es un archivo**, incluso los dispositivos.
- Hay que usarlo con cuidado: un error en `if`/`of` puede borrar todo un disco.
- Aunque su sintaxis es antigua, sigue siendo esencial para administradores de sistemas y seguridad informÃ¡tica.

ğŸ‘‰ Para tareas simples, mejor usar `cp`, `rsync` o `tar`. Para clonado de discos/USBs, `dd` sigue siendo el rey.

---

[ğŸ”¼](#Ã­ndice)

---

## **423. CÃ³mo usar el comando dd en Linux**

### Resumen rÃ¡pido

`dd` copia datos **byte a byte** entre _archivos_ o _dispositivos_ (`if=` input file, `of=` output file). Se usa para crear imÃ¡genes, clonar discos/particiones, generar archivos de prueba, borrar unidades, medir I/O y mÃ¡s.

Sintaxis bÃ¡sica:

```bash
sudo dd if=ORIGEN of=DESTINO [bs=BLOCKSIZE] [count=N] [opciones]
```

Siempre ejecuta con `sudo` cuando trabajas con dispositivos de bloque (`/dev/sdX`).

### Antes de empezar â€” checklist de seguridad

1. **Identifica correctamente** el dispositivo destino: `lsblk`, `blkid`, `fdisk -l`.
2. **Desmonta** la particiÃ³n del destino: `sudo umount /dev/sdb1` (si estÃ¡ montada).
3. **Haz backup** si hay datos importantes.
4. Revisa dos veces `if=` y `of=`. El orden importa: `if=/dev/sda of=/dev/sdb` copia sda â†’ sdb.
5. Usa `status=progress` o `pv` para ver progreso.
6. Ten paciencia â€” operaciones con `dd` pueden tardar bastante.

### Opciones importantes y quÃ© hacen

- `if=` : archivo / dispositivo de entrada (input file).
- `of=` : archivo / dispositivo de salida (output file).
- `bs=` : tamaÃ±o de bloque (ej. `bs=4M`, `bs=64K`). Afecta rendimiento.
- `count=` : nÃºmero de bloques a copiar (stop despuÃ©s de `count*bs` bytes).
- `skip=` : omite N bloques del _input_ antes de copiar.
- `seek=` : omite N bloques en el _output_ antes de comenzar a escribir (Ãºtil para escribir a partir de offset).
- `conv=` : conversiones (ej.: `notrunc`, `noerror`, `sync`, `sparse`, `fdatasync`, `swab`, `ucase`, `lcase`).

  - `noerror` : continÃºa aunque haya errores de lectura.
  - `sync` : rellena bloques cortos con ceros para mantener offsets.
  - `notrunc` : no trunca el archivo de salida.
  - `sparse` : crea archivos sparse al copiar.
  - `fdatasync` / `fsync` : asegurar escritura al disco antes de finalizar.

- `oflag=` / `iflag=` : flags del I/O, p. ej. `direct`, `sync`.

  - `oflag=direct` : evita cache del kernel (mÃ¡s real para tests de disco).
  - `oflag=sync` : escribe sincronamente.

- `status=progress` : muestra progreso (en dd moderno).
- En sistemas sin `status=progress`, puedes enviar seÃ±al USR1 al proceso `dd` para que imprima progreso:

  - `sudo kill -USR1 $(pgrep ^dd$)` (ejecÃºtalo en otro terminal).

### Ejemplos prÃ¡cticos (explicados paso a paso)

#### 1) Crear un archivo de imagen vacÃ­o (100 MB)

```bash
dd if=/dev/zero of=imagen.img bs=1M count=100 status=progress
```

- `if=/dev/zero` genera ceros; `bs=1M count=100` => 100 MB.

#### 2) Crear un archivo â€œsparseâ€ (archivo de gran tamaÃ±o que no ocupa espacio fÃ­sico)

```bash
dd if=/dev/zero of=sparse.img bs=1 count=0 seek=1G
```

- `count=0 seek=1G` crea archivo con tamaÃ±o lÃ³gico 1 GiB sin escribir datos reales.

#### 3) Escribir una ISO a una USB (crear USB booteable)

1. Identifica la unidad: `lsblk` â†’ digamos `/dev/sdb`.
2. Desmonta cualquier particiÃ³n en `/dev/sdb`.
3. Ejecuta:

```bash
sudo dd if=ubuntu.iso of=/dev/sdb bs=4M status=progress oflag=sync
sudo sync
```

- `of=/dev/sdb` (no /dev/sdb1). `oflag=sync` fuerza sincronÃ­a; `sync` asegura que el kernel vacÃ­e buffers.

#### 4) Hacer imagen completa de un disco (backup bit a bit)

```bash
sudo dd if=/dev/sda of=/path/to/backup-sda.img bs=64K status=progress
```

- Para comprimir al vuelo:

```bash
sudo dd if=/dev/sda bs=64K status=progress | gzip > backup-sda.img.gz
```

#### 5) Restaurar imagen a disco

```bash
gunzip -c backup-sda.img.gz | sudo dd of=/dev/sda bs=64K status=progress
```

#### 6) Clonar disco a disco

```bash
sudo dd if=/dev/sda of=/dev/sdb bs=64K status=progress conv=noerror,sync
```

- `noerror` continÃºa ante errores; `sync` rellena bloques cortos con ceros (mantiene offsets).

#### 7) Copiar sÃ³lo los primeros N bytes (p. ej. MBR / primeros 512 bytes)

- Copiar MBR completo (512 bytes):

```bash
sudo dd if=/dev/sda of=mbr.bin bs=512 count=1
```

- Copiar sÃ³lo boot code (primeros 446 bytes):

```bash
sudo dd if=/dev/sda of=bootcode.bin bs=446 count=1
```

> Nota: la tabla de particiones es los 64 bytes siguientes (446..510).

#### 8) Extraer una particiÃ³n a partir de sectores (usar `skip`)

Si la particiÃ³n comienza en el sector 2048 (sector=512 bytes):

```bash
sudo dd if=/dev/sda of=part1.img bs=512 skip=2048 status=progress
```

- Para restaurarla al mismo offset en otro disco usa `seek=2048`:

```bash
sudo dd if=part1.img of=/dev/sdb bs=512 seek=2048 status=progress
```

#### 9) Borrar un disco (sobrescribir con ceros o aleatorios)

- Sobrescribir con ceros (rÃ¡pido):

```bash
sudo dd if=/dev/zero of=/dev/sdx bs=4M status=progress oflag=sync
```

- Sobrescribir con datos aleatorios (mÃ¡s seguro, lento):

```bash
sudo dd if=/dev/urandom of=/dev/sdx bs=1M status=progress
```

> Para borrar de forma segura varias pasadas, es mejor usar `shred` u otras utilidades diseÃ±adas para ello.

#### 10) Medir rendimiento de escritura (benchmark simple)

```bash
sudo dd if=/dev/zero of=testfile bs=1G count=1 oflag=direct status=progress
```

- `oflag=direct` evita cache y te da velocidad real del disco.

#### 11) Ver progreso en versiones antiguas de `dd`

Si `status=progress` no existe:

1. Inicia `dd` en una terminal.
2. En otra terminal, manda seÃ±al:

```bash
sudo pkill -USR1 -n dd
# o
sudo kill -USR1 <pid_de_dd>
```

`dd` imprimirÃ¡ al stderr estadÃ­sticas (bytes copiados y velocidad).

#### 12) Usar `pv` para ver progreso y tasa (si lo tienes instalado)

```bash
pv ubuntu.iso | sudo dd of=/dev/sdb bs=4M oflag=sync
# o para imÃ¡genes grandes
sudo dd if=/dev/sda bs=64K | pv | gzip > backup.img.gz
```

#### 13) Evitar truncar el archivo de salida (Ãºtil al escribir dentro de un archivo existente)

```bash
dd if=data.bin of=bigfile.img bs=512 seek=2048 conv=notrunc
```

`notrunc` evita truncar el archivo de salida antes de escribir.

### `conv=`: usos frecuentes y explicaciÃ³n

- `noerror` â†’ continuar aunque existan errores de lectura.
- `sync` â†’ rellena bloques cortos con ceros, Ãºtil con `noerror` para mantener offsets.
- `fdatasync` / `fsync` â†’ fuerza sincronizaciÃ³n al terminar.
- `sparse` â†’ crear archivos sparse (ahorra espacio).
- `swab` â†’ byte-swap pares (muy especÃ­fico).
- `ucase` / `lcase` â†’ convertir mayÃºsc/minÃºsc (raro en uso real).

Ejemplo combinando:

```bash
sudo dd if=/dev/sda of=backup.img conv=noerror,sync bs=64K status=progress
```

### VerificaciÃ³n despuÃ©s de copiar

Siempre verifica integridad:

- Generar suma en origen y destino:

```bash
sha256sum ubuntu.iso
sha256sum /dev/sdb   # NO funciona directamente; mejor verificar contenido escrito:
sudo dd if=/dev/sdb bs=4M count=xxxx | sha256sum
# o comparar imagen:
sudo dd if=/dev/sdb bs=4M count=xxxx | gzip > copy.gz
```

O mejor: calcula suma del archivo .iso y compara con la suma provista por la distribucion; tras escribir a USB, puedes montar la USB y comparar archivos.

### Casos de uso avanzados

- **RecuperaciÃ³n de discos con sectores daÃ±ados**: usa `ddrescue` o `dd_rescue` â€” herramientas mÃ¡s tolerantes y con logs de reparo.
- **Crear imÃ¡genes comprimidas y manejar espacio**: `dd if=/dev/sda | gzip > /mnt/backup/sda.img.gz`.
- **Crear imÃ¡genes de dispositivos remotos**:

```bash
sudo dd if=/dev/sda | ssh user@host "cat > /path/backup.img"
```

### Errores comunes y cÃ³mo evitarlos

- Confundir particiÃ³n con disco: escribir a `/dev/sdb1` vs `/dev/sdb`.
- No desmontar el dispositivo antes de escribir.
- Usar `bs` demasiado pequeÃ±o â†’ baja velocidad. Usar valores razonables: `bs=64K` a `bs=4M` segÃºn el caso.
- No usar `status=progress` â†’ pensar que `dd` â€œse quedÃ³ pegadoâ€.
- No usar `oflag=sync` cuando necesitas asegurar escritura inmediata.

### Alternativas / herramientas complementarias

- `cp` / `rsync` â†’ para copiar archivos y directorios.
- `partclone`, `fsarchiver` â†’ para clonar particiones manteniendo sÃ³lo bloques usados.
- `ddrescue` â†’ recuperaciÃ³n segura de discos daÃ±ados.
- `pv` â†’ ver progreso, tasa y ETA cuando combinas tuberÃ­as.
- `shred` â†’ borrado seguro multi-pasada.

### Ejemplo prÃ¡ctico â€” flujo completo: grabar ISO a USB y verificar

1. Conecta USB. EncuÃ©ntralo:

```bash
lsblk
# supongamos /dev/sdb
```

2. Desmonta las particiones:

```bash
sudo umount /dev/sdb*
```

3. Graba ISO:

```bash
sudo dd if=ubuntu.iso of=/dev/sdb bs=4M status=progress oflag=sync
```

4. Fuerza escritura final:

```bash
sync
```

5. Monta la USB y verifica (compara archivo, o revisa que arranque en otra mÃ¡quina/VM).

### ConclusiÃ³n y buenas prÃ¡cticas finales

- `dd` es extremadamente potente y versÃ¡til, pero **peligroso** si se usa sin cuidado.
- Usa `lsblk`/`fdisk -l` para identificar dispositivos, desmonta antes, y confirma `if`/`of`.
- Prefiere `status=progress` o `pv` para visibilidad; usa `oflag=sync` o `sync` para asegurar datos.
- Para recuperaciÃ³n, prefiere `ddrescue`.
- Para copias de archivos normales, usa `cp`/`rsync`.

---

[ğŸ”¼](#Ã­ndice)

---

| **Inicio**         | **atrÃ¡s 5**         | **Siguiente 7**      |
| ------------------ | ------------------- | -------------------- |
| [ğŸ ](../README.md) | [âª](./13_5_cat.md) | [â©](./13_7_tail.md) |
