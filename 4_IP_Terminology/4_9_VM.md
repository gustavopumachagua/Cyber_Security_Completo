| **Inicio**         | **atrás 8**        | **Siguiente 10**     |
| ------------------ | ------------------ | -------------------- |
| [🏠](../README.md) | [⏪](./4_8_ARP.md) | [⏩](./4_10_DHCP.md) |

---

## **Índice**

| Temario                                                                                                                                    |
| ------------------------------------------------------------------------------------------------------------------------------------------ |
| [91. ¿Qué es una máquina virtual y cómo funciona?](#91-qué-es-una-máquina-virtual-y-cómo-funciona)                                         |
| [92. Virtualización explicada](#92-virtualización-explicada)                                                                               |
| [93. Explora las publicaciones más importantes sobre Infraestructura](#93-explora-las-publicaciones-más-importantes-sobre-infraestructura) |

# **Virtual Machine**

## **91. ¿Qué es una máquina virtual y cómo funciona?**

![Virtual Machine](/img/4_IP_Terminology/Virtual_Machine.jpg "Virtual Machine")

### 1. Definición de una Máquina Virtual

Una **Máquina Virtual (VM)** es un entorno de software que **emula el hardware físico de un ordenador**, permitiendo ejecutar un sistema operativo y aplicaciones como si fuera una computadora independiente.
Se ejecuta sobre un **hipervisor**, que actúa como capa intermedia entre el hardware real (host) y las VM (guest).

➡️ **Ejemplo simple:**

En una laptop con Windows, puedes instalar **VirtualBox** o **VMware** y crear una VM que ejecute Linux. Esa VM "cree" que tiene su propio CPU, memoria, disco y red, aunque en realidad son recursos virtualizados del hardware físico.

### 2. Conclusiones clave

- Una **VM es un ordenador dentro de otro ordenador**.
- Se usan para **pruebas, desarrollo, seguridad, consolidación de servidores y nube**.
- Funcionan gracias a la **virtualización de hardware** hecha por un hipervisor.
- Aportan **aislamiento**, **flexibilidad** y **eficiencia en recursos**.
- Son la base de la **nube moderna** (AWS, Azure, Google Cloud).

### 3. ¿Cómo funciona una máquina virtual?

- El **hipervisor** asigna recursos físicos (CPU, RAM, disco, red) a la VM.
- El **sistema operativo invitado (guest)** dentro de la VM los usa como si fueran hardware real.
- Se puede tener múltiples VMs en un solo servidor físico, todas independientes.

#### Tipos de hipervisores:

- **Tipo 1 (bare-metal):** se ejecutan directamente sobre el hardware (ej. VMware ESXi, Microsoft Hyper-V, Xen).
- **Tipo 2 (hosted):** se instalan sobre un sistema operativo (ej. VirtualBox, VMware Workstation).

➡️ **Ejemplo:**

Un servidor físico con 64 GB RAM y 16 núcleos puede correr 8 VMs, cada una con 8 GB de RAM y 2 núcleos asignados, todas con SO diferentes.

### 4. ¿Qué beneficios ofrecen las máquinas virtuales?

- **Aislamiento:** un fallo en una VM no afecta a las demás.
- **Optimización de recursos:** varios sistemas corren en un solo servidor físico.
- **Escalabilidad y flexibilidad:** crear o eliminar VMs es rápido.
- **Portabilidad:** se puede mover una VM entre servidores fácilmente (p. ej. con VMware vMotion).
- **Seguridad:** ejecutar aplicaciones o pruebas en una VM evita comprometer el host.
- **Costos reducidos:** menos hardware físico, más eficiencia energética.

### 5. ¿Para qué se utilizan las máquinas virtuales?

- **Entornos de desarrollo y pruebas:** programadores pueden probar software en distintos sistemas operativos sin necesidad de múltiples PCs.
- **Consolidación de servidores:** reemplazar muchos servidores físicos por menos hosts con varias VMs.
- **Seguridad y sandboxing:** probar software sospechoso o malicioso en un entorno aislado.
- **Recuperación ante desastres:** las VMs se respaldan como archivos y se restauran fácilmente.
- **Educación:** aprender a usar diferentes sistemas operativos sin necesidad de hardware dedicado.
- **Cloud computing:** proveedores de nube ofrecen infraestructura basada en VMs bajo demanda.

### 6. Tendencias futuras de las VM

- **Contenedores y microservicios:** aunque las VMs siguen siendo clave, los contenedores (Docker, Kubernetes) están ganando terreno por ser más ligeros.
- **VMs más seguras:** integración con tecnologías de aislamiento de hardware (ej. Intel SGX, AMD SEV).
- **Serverless + VMs efímeras:** servicios que crean y destruyen VMs en segundos para cargas temporales.
- **Edge computing:** despliegue de VMs en dispositivos cercanos al usuario (IoT, 5G).
- **VMs en la nube híbrida:** combinación de entornos on-premises y cloud con VMs portátiles.

✅ **En resumen:**

Las **máquinas virtuales** son una de las tecnologías más importantes en la informática moderna. Han transformado cómo usamos servidores, desarrollamos software y construimos servicios en la nube. Aunque los **contenedores** han ganado protagonismo, las VMs siguen siendo **fundamentales en la infraestructura TI** por su **aislamiento, flexibilidad y seguridad**.

---

[🔼](#índice)

---

## **92. Virtualización explicada**

### 1) ¿Qué es la virtualización?

La **virtualización** es la técnica que permite crear **recursos lógicos (virtuales)** —máquinas, redes, discos, etc.— sobre **hardware físico** compartido. Es decir, permite que varios sistemas operativos y aplicaciones se ejecuten aislados entre sí sobre el mismo servidor físico.

Piensa en un servidor físico como un edificio: la virtualización crea departamentos independientes dentro del mismo edificio, cada uno con su propia puerta, mobiliario y reglas.

### 2) Conceptos clave

- **Host (anfitrión):** servidor físico que aporta CPU, memoria, I/O.
- **Guest (invitado):** sistema operativo / máquina virtual que corre sobre el host.
- **Hipervisor (hypervisor):** software que crea y gestiona VMs; controla acceso a hardware.

  - **Tipo 1 (bare-metal):** corre directo sobre hardware (ej.: VMware ESXi, KVM en Linux, Xen, Microsoft Hyper-V).
  - **Tipo 2 (hosted):** corre sobre un SO anfitrión (ej.: VirtualBox, VMware Workstation).

- **Imagen/plantilla:** archivo que contiene disco del OS invitado (ej.: `.qcow2`, `.vmdk`, `.vhdx`).
- **vCPU / vRAM:** recursos virtuales asignados a la VM.
- **vNIC / vSwitch:** red virtual y switch software que conecta VMs.
- **Disco virtual (virtual disk):** fichero que actúa como disco (thin/thick provisioning).
- **Paravirtualización / drivers para invitados (virtio, VMware Tools):** drivers optimizados que mejoran rendimiento de I/O.

### 3) Tipos de virtualización (resumido y con ejemplos)

- **Virtualización completa / Full virtualization**

  - El hipervisor emula hardware completo; el guest no sabe que es virtual.
  - Ej.: VMware ESXi, KVM + QEMU (cuando emula dispositivos).

- **Paravirtualización**

  - El guest es modificado para cooperar con el hipervisor (menos overhead).
  - Ej.: Xen PV, uso de drivers `virtio` en KVM.

- **Virtualización asistida por hardware**

  - Usa extensiones CPU (Intel VT-x, AMD-V) para acelerar trap/emu y evitar traducción binaria.

- **Virtualización a nivel de sistema operativo (contenedores)**

  - Aislamiento a nivel de procesos / espacio de nombres (Linux namespaces, cgroups). Ej.: Docker, LXC. (No es VM completa; comparte kernel del host).

- **MicroVMs / VMs ligeras**

  - VMs reducidas, rápidas de arrancar y con menor sobrecarga (ej.: Firecracker, Kata Containers).

- **Virtualización de almacenamiento / red / GPU**

  - SDN, SR-IOV, VFIO para pasar HW a invitados, almacenamiento virtual (SAN, iSCSI, Ceph).

### 4) ¿Cómo funciona, técnicamente?

#### Alto nivel

1. El hipervisor controla el hardware y crea entornos virtuales (VMs).
2. Cada VM obtiene vCPUs, vRAM, discos virtuales y vNICs.
3. El hipervisor multiplexa el acceso al hardware real entre las VMs.

#### Bajo nivel — mecanismos comunes

- **Trap-and-emulate / binary translation:** en ausencia de soporte hardware, el hipervisor intercepta instrucciones privilegiadas del guest, las emula o traduce (más lento).
- **Hardware virtualization (VT-x / AMD-V):** permite ejecutar guests en modo “no privilegiado” y pasar traps al hypervisor eficientemente (mejor rendimiento).
- **Passthrough / SR-IOV / VFIO:** pasa un dispositivo físico (NIC, GPU) directamente a la VM para rendimiento cercano al bare-metal.
- **Device emulation vs paravirtual drivers:** la emulación es compatible pero lenta; `virtio`/drivers paravirtualizados reducen costoso I/O emulado.

### 5) Componentes prácticos (qué verás en un entorno real)

- **Archivos de disco:** `vm1.qcow2`, `vm1.vmdk`. (`qcow2` soporta snapshots, compresión).
- **Herramientas de gestión:** `virsh`/`virt-manager` (KVM), `VBoxManage` (VirtualBox), vCenter/vSphere (VMware).
- **Red virtual:** bridges (`br0`), NAT, macvtap, vSwitches (Open vSwitch).
- **Snapshots:** punto en el tiempo del disco/estado; útiles para testing pero no sustituyen backups.
- **Plantillas/Golden images:** instalar OS base + parchear + sysprepping → crear imagen reutilizable.

### 6) Ejemplos prácticos (comandos)

#### Crear una VM rápida con **KVM / virt-install**

```bash
# instalar (Debian/Ubuntu)
sudo apt update
sudo apt install -y qemu-kvm libvirt-daemon-system libvirt-clients virt-manager

# crear una VM desde ISO (ejemplo)
sudo virt-install \
  --name vm-ubuntu \
  --ram 4096 \
  --vcpus 2 \
  --disk size=20 \
  --os-variant ubuntu20.04 \
  --cdrom /path/to/ubuntu.iso \
  --network network=default \
  --graphics none
```

Comandos útiles `virsh`:

```bash
virsh list --all           # listar VMs
virsh start vm-ubuntu      # arrancar
virsh shutdown vm-ubuntu   # apagar
virsh migrate --live vm-ubuntu qemu+ssh://otherhost/system  # migración en vivo
```

#### Crear y lanzar un contenedor (para comparar) — **Docker**

```bash
docker run -it --name alpine-test alpine sh
```

> Nota: el contenedor comparte kernel con el host, arranca mucho más rápido y tiene menos overhead que una VM completa.

#### VirtualBox (CLI) — crear VM

```bash
VBoxManage createvm --name "vm1" --register
VBoxManage modifyvm "vm1" --memory 2048 --cpus 2 --nic1 nat
VBoxManage createhd --filename vm1.vdi --size 20000
# Attach disk & ISO, luego
VBoxManage startvm "vm1" --type headless
```

### 7) ¿Qué beneficios ofrecen las máquinas virtuales / la virtualización?

- **Consolidación de servidores:** menos hardware físico y mayor utilización.
- **Aislamiento:** fallos o cambios en una VM no afectan a otras.
- **Portabilidad:** VMs se mueven entre hosts (migración en vivo).
- **Agilidad:** aprovisionar entornos rápidamente (templates).
- **Recuperación / snapshots:** recuperación de fallos o pruebas.
- **Multi-tenant y cloud:** base para ofrecer infraestructura a terceros.
- **Pruebas y desarrollo:** entornos idénticos reproducibles.

### 8) ¿Para qué se utilizan las VMs? (casos de uso)

- **Data center / cloud (IaaS)**: hosts de máquinas virtuales para clientes.
- **Entornos de desarrollo y testing**: distintas versiones de SO o stacks.
- **VDI (Desktop virtualizado)**: escritorios remotos en VMs.
- **Seguridad / sandboxing**: análisis de malware en entornos aislados.
- **Compatibilidad / legado**: ejecutar apps antiguas en SO antiguos.
- **CI/CD**: runners aislados para pipelines.

### 9) Limitaciones y cuándo no usar VMs

- **Overhead de rendimiento** en comparación con bare-metal (aunque mitigado con para-virtualización y hardware asistido).
- **Consumo de recursos**: cada VM tiene su propio kernel/stack, más memoria que contenedores.
- **Complejidad operativa**: gestionar imágenes, parches, snapshots y sprawl.
- **Coste de licencias** (Windows Server/stack comercial).
- Para cargas ultra-latencia o GPU intensivas, a veces mejor bare-metal o passthrough.

### 10) Optimización y buenas prácticas (operación)

- **Usar drivers paravirtualizados** (`virtio`, VMware Tools, Guest Additions).
- **NUMA awareness / CPU pinning** para workloads sensibles a latencia.
- **HugePages** para bases de datos que usan mucha memoria.
- **SR-IOV / PCI passthrough** para NIC/GPU de alto rendimiento.
- **Reservas y límites** (vCPU, vRAM) para evitar sobrecommit problemático.
- **Política de snapshots**: no mantener snapshots indefinidamente.
- **Backups fuera de la plataforma** (no confiar solo en snapshots).
- **Inventario y control del “VM sprawl”**: etiquetado, lifecycle, automatización.
- **Monitorización**: métricas de host y guests (I/O, CPU steal, ballooning).

### 11) Seguridad: riesgos y mitigaciones

**Riesgos**

- _Hypervisor escape_: un atacante desde una VM intenta ejecutarse en el host.
- _VM sprawl_ → VMs sin parches.
- _Inter-VM side-channel attacks_ (ej. Spectre/Meltdown clases).
- _Robo de imágenes/plantillas_ o acceso no autorizado al datastore.
- _Movilidad insegura_ (migraciones sin cifrado).

**Mitigaciones**

- Mantener hipervisores y firmware parcheados.
- **Minimizar superficie**: hipervisores pequeños, servicios mínimos.
- **Segregar la gestión**: redes separadas para management/VM storage.
- **Cifrado**: discos virtuales cifrados, cifrado de migraciones (TLS).
- **Control de acceso & RBAC** en vCenter/gestor.
- **Microsegmentación** (NSX, security groups) para limitar este-a-ese tráfico entre VMs.
- **vTPM, Secure Boot**, y uso de firmas/whitelisting en VMs.
- **Auditoría y SIEM** para detectar actividad anómala.

### 12) Tendencias futuras de la virtualización

- **MicroVMs** (Firecracker, Kata): unión entre VM y contenedor (arranque rápido + aislamiento fuerte).
- **Virtualización nativa en Kubernetes** (KubeVirt): orquestar VMs con Kubernetes.
- **Confidential computing** (AMD SEV, Intel TDX): VMs cifradas incluso en memoria para multi-tenant seguro.
- **Unikernels**: imágenes muy pequeñas y especializadas que reducen superficie de ataque.
- **Virtualización en el edge / IoT**: VMs ligeras y microVMs en dispositivos de borde.
- **SDN/NFV**: funciones de red virtualizadas (routers, firewalls como VNFs).
- **Infraestructura como código**: Terraform/Ansible para aprovisionar VMs e infra (IaC).
- **Mayor convergencia VM ↔ contenedor**: modelos híbridos (containers dentro de VMs, o microVMs para serverless).

### 13) Comparación rápida: VM vs contenedor

| Característica |                             VM |                              Contenedor |
| -------------- | -----------------------------: | --------------------------------------: |
| Aislamiento    |       Fuerte (kernel separado) |                Menos (comparten kernel) |
| Overhead       |          Mayor (kernel por VM) |                                Muy bajo |
| Portabilidad   |             Imágenes completas |                        Imágenes ligeras |
| Arranque       |             Segundos → minutos |                 Milisegundos → segundos |
| Casos típicos  | Multi-tenant, legacy apps, VDI | Microservicios, CI, despliegues rápidos |

### 14) Mini-cheat-sheet de comandos útiles

**KVM / libvirt**

```bash
virsh list --all
virsh start NOMBRE_VM
virsh shutdown NOMBRE_VM
virsh migrate --live vm qemu+ssh://host2/system
```

**VirtualBox**

```bash
VBoxManage list vms
VBoxManage startvm "vm1" --type headless
VBoxManage controlvm "vm1" acpipowerbutton
```

**Docker (contenedores)**

```bash
docker run -d --name nginx nginx
docker ps -a
docker rm -f container
```

### 15) Conclusión — puntos clave

- La virtualización permite maximizar uso de hardware, ofrecer aislamiento y agilidad operacional.
- Hoy convive con contenedores; no es reemplazada, sino complementada (cada tecnología tiene sus casos de uso).
- Las mejoras en hardware (VT-x/AMD-V), microVMs y Confidential Computing están empujando la virtualización hacia escenarios más seguros y ligeros.
- Operar virtualización a escala exige buenas prácticas (monitorización, parches, backup, control del sprawl y seguridad en la capa de management).

---

[🔼](#índice)

---

## **93. Explora las publicaciones más importantes sobre Infraestructura**

### 1) Categorías y por qué leerlas primero

- **Estándares y RFCs** — base técnica obligatoria (IP, BGP, ARP, VLANs). Te dan la especificación oficial.
- **Papers fundacionales de sistemas distribuidos** — describen ideas que hoy forman la columna vertebral del cloud y big data (GFS, MapReduce, Spanner, Borg). Aprende los patrones arquitectónicos.
- **Libros prácticos y guías** — SRE, IaC, diseño de sistemas de datos: cómo llevar los principios a la práctica.
- **Marcos y whitepapers de proveedores** — AWS Well-Architected, guías de seguridad/NIST: políticas y checklist operacionales.
- **Informes de industria** — DORA, CNCF, Gartner: métricas, prácticas y tendencias del mercado.

### 2) Selección recomendada (Publicaciones clave — descripción + ejemplo práctico)

#### A. **RFCs y estándares (lectura rápida, imprescindible)**

- **RFC 791 — IPv4** (diseño del protocolo IP). Útil para entender direccionamiento, fragmentación y encabezados.
  _Ejemplo práctico:_ repasa RFC 791 antes de planificar subredes y MTU en un datacenter que interconectará equipos legacy con enlaces de baja MTU.
- **RFC 826 — ARP** (Address Resolution Protocol). Explica cómo una IP se resuelve a MAC en LAN — fundamental para debugging de capa 2.
  _Ejemplo práctico:_ cuando depures spoofing o problemas de ARP, usar la especificación para interpretar campos del paquete.
- **RFC 4271 — BGP-4** (enrutamiento inter-AS). Vital para infra de Internet / peering / rutas.
  _Ejemplo práctico:_ diseñar políticas BGP (AS-path prepending, communities) para multihoming.
- **IEEE 802.1Q** (VLAN tagging). Normativa para segmentación L2.
  _Ejemplo práctico:_ plan de VLANs y trunks entre switches (native VLAN, etiquetado 802.1Q).

#### B. **Papers clásicos: cómo están pensadas las infra modernas**

- **The Google File System (GFS)** — diseño de un sistema de archivos distribuido tolerante a fallos. Te enseña diseño para _datos a escala_.

  _Ejemplo práctico:_ conceptos de chunking y replicación ⇒ diseñar un clúster de almacenamiento distribuido o elegir configuración de HDFS/Ceph.

- **MapReduce (Dean & Ghemawat)** — modelo de procesamiento masivo por _map_ y _reduce_. Base de Hadoop/Spark.

  _Ejemplo práctico:_ transformar la lógica de “procesar logs masivos” a un job MapReduce / Spark para calcular métricas de uso.

- **Spanner (Google)** — base de datos transaccional, globalmente distribuida con relojes sincronizados. Enseña consistencia y diseño multizona.

  _Ejemplo práctico:_ si diseñas replicación multi-región, estudiar Spanner aclara trade-offs entre latencia y consistencia.

- **Borg, Omega y Kubernetes (lecciones)** — evolución de la orquestación de contenedores en Google y lecciones aplicables a Kubernetes.

  _Ejemplo práctico:_ diseñar un clúster Kubernetes para cargas multitenant inspirándote en patrones de Borg (scheduling, quotas, binpacking).

- **The Datacenter as a Computer (Barroso & Hölzle)** — trata al datacenter como un “computer” a gran escala: eficiencia, diseño, operación.

  _Ejemplo práctico:_ dimensionar racks, plan de energía y enfriamiento alineado con la lógica de WSC (warehouse-scale computers).

#### C. **Libros y guías operativas (de lectura práctica)**

- **Site Reliability Engineering (SRE) — Google** — principios SRE: SLOs, error budgets, eliminación de toil, monitoreo y gestión de incidentes. Lectura obligatoria para operar infra a escala.

  _Ejemplo práctico:_ define SLOs para un servicio interno (p. ej. 99.9% disponibilidad mensual), calcula error budget y crea playbooks de respuesta.

- **Designing Data-Intensive Applications (Martin Kleppmann)** — patrón de almacenamiento, colas, replicación y tolerancia a fallos. Excelente para arquitectos.

  _Ejemplo práctico:_ elegir entre réplica primaria-secundaria vs consenso (Paxos/Raft) para la base de datos de tu aplicación.

- **Infrastructure as Code (Kief Morris)** — prácticas, patrones y pipeline de IaC. Indispensable si vas a automatizar infra.

  _Ejemplo práctico:_ crear módulos reutilizables en Terraform para redes + seguridad y versionarlos en Git.

- **Terraform: Up & Running (Yevgeniy Brikman)** — guía práctica para Terraform (IaC).

  _Ejemplo práctico:_ escribir código Terraform que cree VPC, subnets, ruteo y un EC2 con user data para desplegar un servicio.

- **The Phoenix Project / The DevOps Handbook** — cultura, flujo de trabajo y transformación organizacional (DevOps).

  _Ejemplo práctico:_ aplicar las “Three Ways” para reducir lead time desde commit a producción.

#### D. **Frameworks, whitepapers y controles de seguridad**

- **AWS Well-Architected Framework** — preguntas y pilares para evaluar arquitecturas cloud (operational excellence, security, reliability, performance, cost, sustainability). Útil como checklist operativo.

  _Ejemplo práctico:_ hacer un Well-Architected review de tu arquitectura y priorizar mejoras (backup, automatización de despliegues, security).

- **NIST SP 800-53** y **ISO/IEC 27001** — controles y requisitos para seguridad / cumplimiento. Útiles para infra regulada.

  _Ejemplo práctico:_ mapear controles NIST a políticas de red (segmentación, logging, access control) para auditoría.

- **DORA / State of DevOps Report** — métricas y prácticas que separan equipos de alto rendimiento: lead time, deployment frequency, MTTR, change fail rate. Útil para cultura y procesos.

  _Ejemplo práctico:_ medir tus cuatro métricas DORA antes/después de implantar CI/CD y comparar resultados.

- **CNCF Cloud Native Survey & reports** — adopción de Kubernetes, observability, tools y tendencias del ecosistema cloud-native.

  _Ejemplo práctico:_ elegir herramientas de observabilidad basadas en tendencias y compatibilidad con Kubernetes.

### 3) Cómo **usar** estas publicaciones (plan de lectura + ejercicios)

Te propongo un **plan práctico de 6–8 semanas** para convertir lectura en habilidad:

**Semana 1 — Fundamentos / RFCs**

- Lee (o repasa) RFC 791 (IPv4) y RFC 826 (ARP).
- Ejercicio: en tu red de laboratorio, captura paquetes ARP/IPv4 con `tcpdump` y relaciona con campos del RFC.

**Semana 2 — Redes y segmentación**

- Lee IEEE 802.1Q (resumen) y BGP basics (RFC 4271).
- Ejercicio: configura VLANs y trunks en dos switches virtuales; simula un pequeño BGP multihomed con FRR/Quagga.

**Semana 3 — Sistemas distribuidos (papers)**

- Lee GFS y MapReduce.
- Ejercicio: procesa logs grandes con Spark (modelo MapReduce) y compara tiempos replicando idea de chunking/GFS.

**Semana 4 — Datos y consistencia**

- Lee capítulos de _Designing Data-Intensive Applications_ sobre replicación y consenso.
- Ejercicio: montar un pequeño cluster de base de datos replicada (Postgres streaming replication o CockroachDB) y comparar comportamientos.

**Semana 5 — Operación y SRE**

- Lee partes clave del libro _Site Reliability Engineering_ (SLOs, monitoring).
- Ejercicio: define SLO/SLA para un servicio y crea un playbook de incident response.

**Semana 6 — IaC y automatización**

- Lee _Infrastructure as Code_ y capítulos prácticos de Terraform.
- Ejercicio: codifica la VPC, subnets y un servicio simple en Terraform; despliega y destruye.

**Semana 7–8 — Revisión y métricas**

- Revisa AWS Well-Architected y DORA report; ejecuta un mini-well-architected review y mide tus métricas DORA.

### 4) Cómo evaluar qué leer según tu rol (atajos)

- **Sysadmin / Network engineer:** empieza por RFCs + 802.1Q + BGP + libros de redes (Tanenbaum / Stevens).
- **SRE / Ops:** SRE book + DORA report + Well-Architected + NIST.
- **Arquitecto de datos:** GFS, MapReduce, Spanner, _Designing Data-Intensive Applications_.
- **Cloud/Infra DevOps:** _Infrastructure as Code_ + Terraform + CNCF reports + Kubernetes lessons (Borg→K8s).

### 5) Ejemplos concretos (mini-casos de aplicación)

1. **Reducir MTTR en servicio web**

   - Usa SRE (SLO + playbooks) + Well-Architected (monitoring/ops) → define SLO 99.9%, instrumenta métricas, crea runbook y automatiza alerting.

2. **Procesamiento de logs a escala**

   - Inspírate en MapReduce/GFS: particiona logs (chunks), ejecuta jobs MapReduce/Spark y replica almacenamiento; compara rendimiento.

3. **Migración a IaC**

   - Reescribe tu playbook manual en Terraform usando patrones de Kief Morris; crea módulos reutilizables y pipeline CI.

### 6) Recursos y lecturas (selección rápida con enlaces)

- **Site Reliability Engineering (Google)** — guía práctica SRE.
- **Designing Data-Intensive Applications** — patrones de datos.
- **GFS / MapReduce / Spanner (papers)** — PDFs y explicaciones.
- **AWS Well-Architected Framework** — whitepaper y preguntas.
- **DORA State of DevOps Report 2024** — métricas y prácticas.
- **CNCF Annual Survey (Cloud Native 2024)** — adopción, tendencias.
- **RFCs (IPv4, ARP, BGP)** — lectura técnica.
- **Infrastructure as Code (Kief Morris) & Terraform: Up & Running** — IaC.

### 7) Consejos finales — cómo no perderte entre tanta lectura

- Prioriza **lectura activa**: no solo leer, **aplica** (laboratorio, repositorios, scripts).
- Usa el **plan de 6–8 semanas** (arriba) y mide progreso con ejercicios reales.
- Lee un **paper** + seguido de un **capítulo de libro** que lo contextualice (p. ej. GFS → capítulos relevantes en _Designing Data-Intensive Applications_ o _Datacenter as a Computer_).
- Mantén un **cuaderno de arquitectura**: para cada publicación anota “principio”, “cómo lo aplicaría” y “experimento a realizar”.

---

[🔼](#índice)

---

| **Inicio**         | **atrás 8**        | **Siguiente 10**     |
| ------------------ | ------------------ | -------------------- |
| [🏠](../README.md) | [⏪](./4_8_ARP.md) | [⏩](./4_10_DHCP.md) |
